{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Structurizr DSL This GitHub repository contains an implementation of the Structurizr DSL - a way to create Structurizr software architecture models based upon the C4 model using a textual domain specific language (DSL). The Structurizr DSL has appeared on the ThoughtWorks Tech Radar - Techniques - Diagrams as code . Getting started Getting started with Structurizr Lite (using the DSL) Getting started with the Structurizr CLI and DSL Structurizr DSL demo Reference Language reference Changelog Structurizr DSL cookbook (this is a work in progress) A quick example As an example, the following text can be used to create a software architecture model and an associated view that describes a user using a software system. workspace { model { user = person \"User\" softwareSystem = softwareSystem \"Software System\" user -> softwareSystem \"Uses\" } views { systemContext softwareSystem { include * autolayout } theme default } } ( view this example ) Multiple output formats The DSL can be rendered using a number of tools: Structurizr Lite (free) Structurizr cloud service/on-premises installation (free and paid), PlantUML, Mermaid, DOT (Graphviz), WebSequenceDiagrams, and Ilograph via the Structurizr CLI Convention over configuration, useful defaults The DSL is designed to be as compact as possible. In conjunction with the Structurizr CLI, the following DSL fragment will automatically create the implied relationship between the user and softwareSystem elements, create three views with auto-layout enabled (1 x System Landscape, 1 x System Context, 1 x Container), and add some default element styles. workspace { model { user = person \"User\" softwareSystem = softwareSystem \"Software System\" { webapp = container \"Web Application\" database = container \"Database\" } user -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" } views { theme default } } Examples Getting started Big Bank plc Amazon Web Services Tooling support Here are some tools designed to support the Structurizr DSL. Structurizr Lite (web-based rendering tool) c4viz (web-based rendering tool) Structurizr CLI (command line utilities) VS Code extension (syntax highlighting and diagram previews; please note that there are some known issues with the syntax highlighting - see Divergences for more details, and Examples for examples that work correctly with the extension) VS Code extension (syntax highlighting)","title":"Home"},{"location":"#structurizr-dsl","text":"This GitHub repository contains an implementation of the Structurizr DSL - a way to create Structurizr software architecture models based upon the C4 model using a textual domain specific language (DSL). The Structurizr DSL has appeared on the ThoughtWorks Tech Radar - Techniques - Diagrams as code .","title":"Structurizr DSL"},{"location":"#getting-started","text":"Getting started with Structurizr Lite (using the DSL) Getting started with the Structurizr CLI and DSL Structurizr DSL demo","title":"Getting started"},{"location":"#reference","text":"Language reference Changelog Structurizr DSL cookbook (this is a work in progress)","title":"Reference"},{"location":"#a-quick-example","text":"As an example, the following text can be used to create a software architecture model and an associated view that describes a user using a software system. workspace { model { user = person \"User\" softwareSystem = softwareSystem \"Software System\" user -> softwareSystem \"Uses\" } views { systemContext softwareSystem { include * autolayout } theme default } } ( view this example )","title":"A quick example"},{"location":"#multiple-output-formats","text":"The DSL can be rendered using a number of tools: Structurizr Lite (free) Structurizr cloud service/on-premises installation (free and paid), PlantUML, Mermaid, DOT (Graphviz), WebSequenceDiagrams, and Ilograph via the Structurizr CLI","title":"Multiple output formats"},{"location":"#convention-over-configuration-useful-defaults","text":"The DSL is designed to be as compact as possible. In conjunction with the Structurizr CLI, the following DSL fragment will automatically create the implied relationship between the user and softwareSystem elements, create three views with auto-layout enabled (1 x System Landscape, 1 x System Context, 1 x Container), and add some default element styles. workspace { model { user = person \"User\" softwareSystem = softwareSystem \"Software System\" { webapp = container \"Web Application\" database = container \"Database\" } user -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" } views { theme default } }","title":"Convention over configuration, useful defaults"},{"location":"#examples","text":"Getting started Big Bank plc Amazon Web Services","title":"Examples"},{"location":"#tooling-support","text":"Here are some tools designed to support the Structurizr DSL. Structurizr Lite (web-based rendering tool) c4viz (web-based rendering tool) Structurizr CLI (command line utilities) VS Code extension (syntax highlighting and diagram previews; please note that there are some known issues with the syntax highlighting - see Divergences for more details, and Examples for examples that work correctly with the extension) VS Code extension (syntax highlighting)","title":"Tooling support"},{"location":"building/","text":"Building To build this repo from the sources (you'll need git and Java 11+ installed)... git clone https://github.com/structurizr/dsl.git structurizr-dsl cd structurizr-dsl ./gradlew","title":"Building"},{"location":"building/#building","text":"To build this repo from the sources (you'll need git and Java 11+ installed)... git clone https://github.com/structurizr/dsl.git structurizr-dsl cd structurizr-dsl ./gradlew","title":"Building"},{"location":"changelog/","text":"Changelog 1.21.0 (unreleased to Maven Central) Fixes #153 (Error when deploymentNode identifier is the same as a softwareSystem or container identifier) Adds support for custom elements on dynamic views. The DSL parser will now throw an error if the enterprise is set more than once (#159). Adds the ability to set name/value properties on element and relationship styles. Adds support for setting element style stroke widths. Adds name-value properties to views. Adds support for using theme and themes inside the styles block. 1.20.0 (15th August 2022) Fixes #130 (Incorrect displaying of multiple urls within a container). Added more validation for supported icon types (PNG and JPG, not SVG). Adds support for instances as child of deploymentNode (#133). Fixes #142 (Invalid object scoping strategy). Adds support for explicitly specifying the relationships that should be added to dynamic views. Adds support for setting workspace properties. 1.19.1 (30th March 2022) title now works for custom views. Adds description to set view descriptions. 1.19.0 (23rd March 2022) Uses the new documentation/ADR importers, and makes it possible to use a custom implementation via !docs and !adrs . 1.18.0 (20th February 2022) Removes backwards compatibility for unquoted expressions (e.g. exclude src -> dest - use exclude \"src -> dest\" instead). Adds the ability to include/exclude relationships by the tag of source of destination elements (e.g. exclude \"* -> element.tag==Tag\" ). Adds support for directory based includes with !include . Adds support for element expressions to be used in the afferent/efferent coupling expression (e.g. exclude \"->element.tag==Tag\" ) Adds support for element expressions of the form element.parent==<identifier> . Fixes #113 (Excluding relationships with tags in a Deployment Diagram). 1.17.0 (4th January 2022) Adds support for extending deployment environments via the !ref keyword (issue #92). Adds support for extending relationships via the !ref keyword (issue #93). Fixes #94 (tabs cause parsing errors). Adds support for different relationship line styles (solid, dashed, dotted). Adds support for name/value properties on the view set. 1.16.0 (26th November 2021) Adds the implied relationships functionality for custom elements. The \"add default elements\" feature ( include * ) will now also add any connected custom elements. Adds better support for custom elements when using element expressions. Adds a description keyword for setting the description on elements. Adds a technology keyword for setting the technology on containers, components, deployment nodes, and infrastructure nodes. 1.15.0 (2nd October 2021) Adds support for specifying element style icons and the branding logo as a HTTPS/HTTP URL. Adds support for relationships from deployment nodes to infrastructure nodes. Fixes an issue where this didn't work when defining relationships inside deployment/infrastructure nodes. Removes the restriction that include * must be on a line of its own inside view definitions. 1.14.0 (19th September 2021) Breaking change : Adds support for software system/container instances in multiple deployment groups. Fixes an issue where internal software systems/people are not included by the DSL formatter when the enterprise is not set. The DSL formatter now removes empty tokens at the end of lines. Adds support for recognising escaped newlines (\\n) in tokens. 1.13.0 (3rd September 2021) Breaking change : impliedRelationships is now !impliedRelationships . Adds support for \"include relationship==*\" (#68). Fixes #69 (hierarchical identifiers not working at the top level inside a deployment environment). Adds experimental support for !ref , !plugin , and !script . 1.12.0 (30th June 2021) Adds an !identifiers keyword to specify whether element identifiers should be flat (default) or hierarchical . Adds support for a this identifier when defining relationships inside element definitions. Fixes links between ADRs. 1.11.0 (7th June 2021) Breaking change : Default styles are no longer added; use the default theme to add some default styles instead. Breaking change : Relationship expressions (e.g. * -> *) now need to be surrounded in double quotes. Support parallel activities in dynamic view (issue #53). Adds a tags keyword for adding tags to elements/relationships. Adds a theme keyword for adding a single theme. Adds support to !include from a HTTPS URL. Adds support for referencing groups by identifier. Adds support for extending a workspace. 1.10.0 (27th April 2021) First version released onto Maven Central.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#1210-unreleased-to-maven-central","text":"Fixes #153 (Error when deploymentNode identifier is the same as a softwareSystem or container identifier) Adds support for custom elements on dynamic views. The DSL parser will now throw an error if the enterprise is set more than once (#159). Adds the ability to set name/value properties on element and relationship styles. Adds support for setting element style stroke widths. Adds name-value properties to views. Adds support for using theme and themes inside the styles block.","title":"1.21.0 (unreleased to Maven Central)"},{"location":"changelog/#1200-15th-august-2022","text":"Fixes #130 (Incorrect displaying of multiple urls within a container). Added more validation for supported icon types (PNG and JPG, not SVG). Adds support for instances as child of deploymentNode (#133). Fixes #142 (Invalid object scoping strategy). Adds support for explicitly specifying the relationships that should be added to dynamic views. Adds support for setting workspace properties.","title":"1.20.0 (15th August 2022)"},{"location":"changelog/#1191-30th-march-2022","text":"title now works for custom views. Adds description to set view descriptions.","title":"1.19.1 (30th March 2022)"},{"location":"changelog/#1190-23rd-march-2022","text":"Uses the new documentation/ADR importers, and makes it possible to use a custom implementation via !docs and !adrs .","title":"1.19.0 (23rd March 2022)"},{"location":"changelog/#1180-20th-february-2022","text":"Removes backwards compatibility for unquoted expressions (e.g. exclude src -> dest - use exclude \"src -> dest\" instead). Adds the ability to include/exclude relationships by the tag of source of destination elements (e.g. exclude \"* -> element.tag==Tag\" ). Adds support for directory based includes with !include . Adds support for element expressions to be used in the afferent/efferent coupling expression (e.g. exclude \"->element.tag==Tag\" ) Adds support for element expressions of the form element.parent==<identifier> . Fixes #113 (Excluding relationships with tags in a Deployment Diagram).","title":"1.18.0 (20th February 2022)"},{"location":"changelog/#1170-4th-january-2022","text":"Adds support for extending deployment environments via the !ref keyword (issue #92). Adds support for extending relationships via the !ref keyword (issue #93). Fixes #94 (tabs cause parsing errors). Adds support for different relationship line styles (solid, dashed, dotted). Adds support for name/value properties on the view set.","title":"1.17.0 (4th January 2022)"},{"location":"changelog/#1160-26th-november-2021","text":"Adds the implied relationships functionality for custom elements. The \"add default elements\" feature ( include * ) will now also add any connected custom elements. Adds better support for custom elements when using element expressions. Adds a description keyword for setting the description on elements. Adds a technology keyword for setting the technology on containers, components, deployment nodes, and infrastructure nodes.","title":"1.16.0 (26th November 2021)"},{"location":"changelog/#1150-2nd-october-2021","text":"Adds support for specifying element style icons and the branding logo as a HTTPS/HTTP URL. Adds support for relationships from deployment nodes to infrastructure nodes. Fixes an issue where this didn't work when defining relationships inside deployment/infrastructure nodes. Removes the restriction that include * must be on a line of its own inside view definitions.","title":"1.15.0 (2nd October 2021)"},{"location":"changelog/#1140-19th-september-2021","text":"Breaking change : Adds support for software system/container instances in multiple deployment groups. Fixes an issue where internal software systems/people are not included by the DSL formatter when the enterprise is not set. The DSL formatter now removes empty tokens at the end of lines. Adds support for recognising escaped newlines (\\n) in tokens.","title":"1.14.0 (19th September 2021)"},{"location":"changelog/#1130-3rd-september-2021","text":"Breaking change : impliedRelationships is now !impliedRelationships . Adds support for \"include relationship==*\" (#68). Fixes #69 (hierarchical identifiers not working at the top level inside a deployment environment). Adds experimental support for !ref , !plugin , and !script .","title":"1.13.0 (3rd September 2021)"},{"location":"changelog/#1120-30th-june-2021","text":"Adds an !identifiers keyword to specify whether element identifiers should be flat (default) or hierarchical . Adds support for a this identifier when defining relationships inside element definitions. Fixes links between ADRs.","title":"1.12.0 (30th June 2021)"},{"location":"changelog/#1110-7th-june-2021","text":"Breaking change : Default styles are no longer added; use the default theme to add some default styles instead. Breaking change : Relationship expressions (e.g. * -> *) now need to be surrounded in double quotes. Support parallel activities in dynamic view (issue #53). Adds a tags keyword for adding tags to elements/relationships. Adds a theme keyword for adding a single theme. Adds support to !include from a HTTPS URL. Adds support for referencing groups by identifier. Adds support for extending a workspace.","title":"1.11.0 (7th June 2021)"},{"location":"changelog/#1100-27th-april-2021","text":"First version released onto Maven Central.","title":"1.10.0 (27th April 2021)"},{"location":"cookbook/","text":"Structurizr DSL cookbook Creating software architecture diagrams from a textual definition is becoming more popular, but it's easy to introduce inconsistencies into your diagrams if you don't keep the multiple source files in sync. This cookbook is a guide to the Structurizr DSL, an open source tool for creating diagrams as code from a single consistent model. Table of contents Introduction Workspace Workspace extension System Context view Container view Component view Filtered view Dynamic view Deployment view Perspectives Amazon Web Services Element styles Relationship styles Themes Implied relationships Scripts DSL and code (hybrid usage pattern)","title":"Structurizr DSL cookbook"},{"location":"cookbook/#structurizr-dsl-cookbook","text":"Creating software architecture diagrams from a textual definition is becoming more popular, but it's easy to introduce inconsistencies into your diagrams if you don't keep the multiple source files in sync. This cookbook is a guide to the Structurizr DSL, an open source tool for creating diagrams as code from a single consistent model.","title":"Structurizr DSL cookbook"},{"location":"cookbook/#table-of-contents","text":"Introduction Workspace Workspace extension System Context view Container view Component view Filtered view Dynamic view Deployment view Perspectives Amazon Web Services Element styles Relationship styles Themes Implied relationships Scripts DSL and code (hybrid usage pattern)","title":"Table of contents"},{"location":"cookbook/amazon-web-services/","text":"Amazon Web Services A deployment view can be used to model the deployment of your software system onto Amazon Web Services. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" \"\" \"Spring Boot\" database = container \"Database\" \"\" \"Relational database schema\" } u -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" live = deploymentEnvironment \"Live\" { deploymentNode \"Amazon Web Services\" { deploymentNode \"US-East-1\" { route53 = infrastructureNode \"Route 53\" elb = infrastructureNode \"Elastic Load Balancer\" deploymentNode \"Amazon EC2\" { deploymentNode \"Ubuntu Server\" { webApplicationInstance = containerInstance webapp } } deploymentNode \"Amazon RDS\" { deploymentNode \"MySQL\" { containerInstance database } } } } route53 -> elb \"Forwards requests to\" \"HTTPS\" elb -> webApplicationInstance \"Forwards requests to\" \"HTTPS\" } } views { deployment s live { include * autoLayout lr } } } This DSL defines a deployment environment named Live , with a hierarchy of deployment nodes showing the various AWS services in use for deployment. It also defines some infrastructure nodes representing services that don't have any software systems/containers deployed onto them. The pre-built Amazon Web Services theme can be used to add some colour, and make use of the AWS icon set. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" \"\" \"Spring Boot\" database = container \"Database\" \"\" \"Relational database schema\" } u -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" live = deploymentEnvironment \"Live\" { deploymentNode \"Amazon Web Services\" { tags \"Amazon Web Services - Cloud\" deploymentNode \"US-East-1\" { tags \"Amazon Web Services - Region\" route53 = infrastructureNode \"Route 53\" { tags \"Amazon Web Services - Route 53\" } elb = infrastructureNode \"Elastic Load Balancer\" { tags \"Amazon Web Services - Elastic Load Balancing\" } deploymentNode \"Amazon EC2\" { tags \"Amazon Web Services - EC2\" deploymentNode \"Ubuntu Server\" { webApplicationInstance = containerInstance webapp } } deploymentNode \"Amazon RDS\" { tags \"Amazon Web Services - RDS\" deploymentNode \"MySQL\" { tags \"Amazon Web Services - RDS MySQL instance\" containerInstance database } } } } route53 -> elb \"Forwards requests to\" \"HTTPS\" elb -> webApplicationInstance \"Forwards requests to\" \"HTTPS\" } } views { deployment s live { include * autoLayout lr } theme https://static.structurizr.com/themes/amazon-web-services-2020.04.30/theme.json } } This DSL adds some element tags, and a reference to the Amazon Web Services theme. Further styles can be added if desired too.","title":"Amazon Web Services"},{"location":"cookbook/amazon-web-services/#amazon-web-services","text":"A deployment view can be used to model the deployment of your software system onto Amazon Web Services. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" \"\" \"Spring Boot\" database = container \"Database\" \"\" \"Relational database schema\" } u -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" live = deploymentEnvironment \"Live\" { deploymentNode \"Amazon Web Services\" { deploymentNode \"US-East-1\" { route53 = infrastructureNode \"Route 53\" elb = infrastructureNode \"Elastic Load Balancer\" deploymentNode \"Amazon EC2\" { deploymentNode \"Ubuntu Server\" { webApplicationInstance = containerInstance webapp } } deploymentNode \"Amazon RDS\" { deploymentNode \"MySQL\" { containerInstance database } } } } route53 -> elb \"Forwards requests to\" \"HTTPS\" elb -> webApplicationInstance \"Forwards requests to\" \"HTTPS\" } } views { deployment s live { include * autoLayout lr } } } This DSL defines a deployment environment named Live , with a hierarchy of deployment nodes showing the various AWS services in use for deployment. It also defines some infrastructure nodes representing services that don't have any software systems/containers deployed onto them. The pre-built Amazon Web Services theme can be used to add some colour, and make use of the AWS icon set. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" \"\" \"Spring Boot\" database = container \"Database\" \"\" \"Relational database schema\" } u -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" live = deploymentEnvironment \"Live\" { deploymentNode \"Amazon Web Services\" { tags \"Amazon Web Services - Cloud\" deploymentNode \"US-East-1\" { tags \"Amazon Web Services - Region\" route53 = infrastructureNode \"Route 53\" { tags \"Amazon Web Services - Route 53\" } elb = infrastructureNode \"Elastic Load Balancer\" { tags \"Amazon Web Services - Elastic Load Balancing\" } deploymentNode \"Amazon EC2\" { tags \"Amazon Web Services - EC2\" deploymentNode \"Ubuntu Server\" { webApplicationInstance = containerInstance webapp } } deploymentNode \"Amazon RDS\" { tags \"Amazon Web Services - RDS\" deploymentNode \"MySQL\" { tags \"Amazon Web Services - RDS MySQL instance\" containerInstance database } } } } route53 -> elb \"Forwards requests to\" \"HTTPS\" elb -> webApplicationInstance \"Forwards requests to\" \"HTTPS\" } } views { deployment s live { include * autoLayout lr } theme https://static.structurizr.com/themes/amazon-web-services-2020.04.30/theme.json } } This DSL adds some element tags, and a reference to the Amazon Web Services theme. Further styles can be added if desired too.","title":"Amazon Web Services"},{"location":"cookbook/component-view/","text":"Component view A component view allows you to zoom-in to a container, to see the components that reside inside it. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" { c1 = component \"Component 1\" c2 = component \"Component 2\" } database = container \"Database\" } u -> c1 \"Uses\" c1 -> c2 \"Uses\" c2 -> database \"Reads from and writes to\" } views { component webapp { include * autoLayout lr } } } This DSL defines a component view for the container webapp , and include * includes the default set of model elements for the view. Component views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command . Links DSL language reference - component","title":"Component view"},{"location":"cookbook/component-view/#component-view","text":"A component view allows you to zoom-in to a container, to see the components that reside inside it. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" { c1 = component \"Component 1\" c2 = component \"Component 2\" } database = container \"Database\" } u -> c1 \"Uses\" c1 -> c2 \"Uses\" c2 -> database \"Reads from and writes to\" } views { component webapp { include * autoLayout lr } } } This DSL defines a component view for the container webapp , and include * includes the default set of model elements for the view. Component views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command .","title":"Component view"},{"location":"cookbook/component-view/#links","text":"DSL language reference - component","title":"Links"},{"location":"cookbook/container-view/","text":"Container view A container view allows you to zoom-in to the software system shown on a system context view, to see the applications and data stores (what the C4 model refers to as \"containers\") that reside inside it. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" database = container \"Database\" } u -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" } views { container s { include * autoLayout lr } } } This DSL defines a container view for the software system s , and include * includes the default set of model elements for the view. Container views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command . Links DSL language reference - container","title":"Container view"},{"location":"cookbook/container-view/#container-view","text":"A container view allows you to zoom-in to the software system shown on a system context view, to see the applications and data stores (what the C4 model refers to as \"containers\") that reside inside it. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" database = container \"Database\" } u -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" } views { container s { include * autoLayout lr } } } This DSL defines a container view for the software system s , and include * includes the default set of model elements for the view. Container views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command .","title":"Container view"},{"location":"cookbook/container-view/#links","text":"DSL language reference - container","title":"Links"},{"location":"cookbook/deployment-view/","text":"Deployment view A deployment view allows you to show how software systems and containers are deployed, by showing the mapping of software system and container instances onto deployment nodes. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" \"\" \"Spring Boot\" database = container \"Database\" \"\" \"Relational database schema\" } u -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" development = deploymentEnvironment \"Development\" { deploymentNode \"Developer Laptop\" { containerInstance webapp deploymentNode \"MySQL\" { containerInstance database } } } } views { deployment * development { include * autoLayout lr } } } This DSL defines a deployment environment named Development , with instances of the webapp and database containers deployed onto some deployment nodes. It also defines a deployment view for this deployment environment, and include * includes the default set of model elements for the view. Deployment views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command . Links DSL language reference - deployment","title":"Deployment view"},{"location":"cookbook/deployment-view/#deployment-view","text":"A deployment view allows you to show how software systems and containers are deployed, by showing the mapping of software system and container instances onto deployment nodes. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" \"\" \"Spring Boot\" database = container \"Database\" \"\" \"Relational database schema\" } u -> webapp \"Uses\" webapp -> database \"Reads from and writes to\" development = deploymentEnvironment \"Development\" { deploymentNode \"Developer Laptop\" { containerInstance webapp deploymentNode \"MySQL\" { containerInstance database } } } } views { deployment * development { include * autoLayout lr } } } This DSL defines a deployment environment named Development , with instances of the webapp and database containers deployed onto some deployment nodes. It also defines a deployment view for this deployment environment, and include * includes the default set of model elements for the view. Deployment views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command .","title":"Deployment view"},{"location":"cookbook/deployment-view/#links","text":"DSL language reference - deployment","title":"Links"},{"location":"cookbook/dsl-and-code/","text":"DSL and code It's possible to use both the DSL and a code-based library together - perhaps you want to define a basic model via the DSL, and use automatic extraction to add components to the model. To do this, define your workspace using the DSL as normal, for example: workspace { model { s = softwareSystem \"Software System\" { webapp = container \"Web Application\" database = container \"Database\" { webapp -> this \"Reads from and writes to\" } } } views { container s { include * autoLayout lr } } } Java Since the DSL parser is written in Java, you can use it directly by adding a dependency on the structurizr-dsl library, which is available on Maven Central : groupId: com.structurizr artifactId: structurizr-dsl You can then write a Java program that parses your DSL definition, and extends the workspace further; for example: StructurizrDslParser parser = new StructurizrDslParser(); parser.parse(new File(\"workspace.dsl\")); Workspace workspace = parser.getWorkspace(); Container webApplication = workspace.getModel().getSoftwareSystemWithName(\"Software System\").getContainerWithName(\"Web Application\"); // add components manually or via automatic extraction ... // add a component view ComponentView componentView = workspace.getViews().createComponentView(webApplication, \"Components\", \"Description\"); componentView.addDefaultElements(); componentView.enableAutomaticLayout(); Please note that the Structurizr for Java library is designed to be append only , so it's not possible to remove/modify elements/relationships that already exist in the model. Other languages Ports of the \"Structurizr for Java\" library are available for a number of other programming languages - see https://structurizr.org/#authoring for links. Although you can't use the DSL parser directly, you can achieve the same effect with the following steps: 1. Convert your DSL workspace to the JSON format This can be done using the Structurizr CLI export command : structurizr export -workspace workspace.dsl -format json 2. Load the JSON file, and add to the workspace A Structurizr for .NET version of the above example is as follows: FileInfo fileInfo = new FileInfo(\"workspace.json\"); Workspace workspace = WorkspaceUtils.LoadWorkspaceFromJson(fileInfo); Container webApplication = workspace.Model.GetSoftwareSystemWithName(\"Software System\").GetContainerWithName(\"Web Application\"); // add components manually or via automatic extraction ... // add a component view ComponentView componentView = workspace.Views.CreateComponentView(webApplication, \"Components\", \"Description\"); componentView.AddDefaultElements(); componentView.EnableAutomaticLayout();","title":"DSL and code"},{"location":"cookbook/dsl-and-code/#dsl-and-code","text":"It's possible to use both the DSL and a code-based library together - perhaps you want to define a basic model via the DSL, and use automatic extraction to add components to the model. To do this, define your workspace using the DSL as normal, for example: workspace { model { s = softwareSystem \"Software System\" { webapp = container \"Web Application\" database = container \"Database\" { webapp -> this \"Reads from and writes to\" } } } views { container s { include * autoLayout lr } } }","title":"DSL and code"},{"location":"cookbook/dsl-and-code/#java","text":"Since the DSL parser is written in Java, you can use it directly by adding a dependency on the structurizr-dsl library, which is available on Maven Central : groupId: com.structurizr artifactId: structurizr-dsl You can then write a Java program that parses your DSL definition, and extends the workspace further; for example: StructurizrDslParser parser = new StructurizrDslParser(); parser.parse(new File(\"workspace.dsl\")); Workspace workspace = parser.getWorkspace(); Container webApplication = workspace.getModel().getSoftwareSystemWithName(\"Software System\").getContainerWithName(\"Web Application\"); // add components manually or via automatic extraction ... // add a component view ComponentView componentView = workspace.getViews().createComponentView(webApplication, \"Components\", \"Description\"); componentView.addDefaultElements(); componentView.enableAutomaticLayout(); Please note that the Structurizr for Java library is designed to be append only , so it's not possible to remove/modify elements/relationships that already exist in the model.","title":"Java"},{"location":"cookbook/dsl-and-code/#other-languages","text":"Ports of the \"Structurizr for Java\" library are available for a number of other programming languages - see https://structurizr.org/#authoring for links. Although you can't use the DSL parser directly, you can achieve the same effect with the following steps:","title":"Other languages"},{"location":"cookbook/dsl-and-code/#1-convert-your-dsl-workspace-to-the-json-format","text":"This can be done using the Structurizr CLI export command : structurizr export -workspace workspace.dsl -format json","title":"1. Convert your DSL workspace to the JSON format"},{"location":"cookbook/dsl-and-code/#2-load-the-json-file-and-add-to-the-workspace","text":"A Structurizr for .NET version of the above example is as follows: FileInfo fileInfo = new FileInfo(\"workspace.json\"); Workspace workspace = WorkspaceUtils.LoadWorkspaceFromJson(fileInfo); Container webApplication = workspace.Model.GetSoftwareSystemWithName(\"Software System\").GetContainerWithName(\"Web Application\"); // add components manually or via automatic extraction ... // add a component view ComponentView componentView = workspace.Views.CreateComponentView(webApplication, \"Components\", \"Description\"); componentView.AddDefaultElements(); componentView.EnableAutomaticLayout();","title":"2. Load the JSON file, and add to the workspace"},{"location":"cookbook/dynamic-view/","text":"Dynamic view A dynamic view allows you to show a subset of the elements in a model, and the relationships between them, in order to describe how a particular use case/story/feature works. Dynamic views show ordered instances of relationships, therefore reducing the number of relationships you need to define in the static model - see Modelling multiple relationships for more. workspace { model { customer = person \"Customer\" onlineBookStore = softwareSystem \"Online book store\" { webapp = container \"Web Application\" database = container \"Database\" } customer -> webapp \"Browses and makes purchases using\" webapp -> database \"Reads from and writes to\" } views { container onlineBookStore { include * autoLayout lr } dynamic onlineBookStore { title \"Request past orders feature\" customer -> webapp \"Requests past orders from\" webapp -> database \"Queries for orders using\" autoLayout lr } dynamic onlineBookStore { title \"Browse top 20 books feature\" customer -> webapp \"Requests the top 20 books from\" webapp -> database \"Queries the top 20 books using\" autoLayout lr } } } This DSL defines three views: A container view showing the user and containers - notice how the relationship between the user and the web application is quite general (\"Browses and makes purchases using\"). A dynamic view for the \"request past orders\" feature. A dynamic view for the \"browse top 20 books\" feature. Dynamic views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command . Links DSL language reference - dynamic","title":"Dynamic view"},{"location":"cookbook/dynamic-view/#dynamic-view","text":"A dynamic view allows you to show a subset of the elements in a model, and the relationships between them, in order to describe how a particular use case/story/feature works. Dynamic views show ordered instances of relationships, therefore reducing the number of relationships you need to define in the static model - see Modelling multiple relationships for more. workspace { model { customer = person \"Customer\" onlineBookStore = softwareSystem \"Online book store\" { webapp = container \"Web Application\" database = container \"Database\" } customer -> webapp \"Browses and makes purchases using\" webapp -> database \"Reads from and writes to\" } views { container onlineBookStore { include * autoLayout lr } dynamic onlineBookStore { title \"Request past orders feature\" customer -> webapp \"Requests past orders from\" webapp -> database \"Queries for orders using\" autoLayout lr } dynamic onlineBookStore { title \"Browse top 20 books feature\" customer -> webapp \"Requests the top 20 books from\" webapp -> database \"Queries the top 20 books using\" autoLayout lr } } } This DSL defines three views: A container view showing the user and containers - notice how the relationship between the user and the web application is quite general (\"Browses and makes purchases using\"). A dynamic view for the \"request past orders\" feature. A dynamic view for the \"browse top 20 books\" feature. Dynamic views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command .","title":"Dynamic view"},{"location":"cookbook/dynamic-view/#links","text":"DSL language reference - dynamic","title":"Links"},{"location":"cookbook/element-styles/","text":"Element styles By default all elements are styled as grey boxes. Styling all elements To change the style for all elements, add an element style for the Element tag. workspace { model { a = softwareSystem \"A\" b = softwareSystem \"B\" c = softwareSystem \"C\" a -> b b -> c } views { systemLandscape { include * autolayout lr } styles { element \"Element\" { background #1168bd color #ffffff shape RoundedBox } } } } Styling individual elements To change the style of an individual element: Tag the element. Add an element style for that tag. workspace { model { a = softwareSystem \"A\" { tags \"Tag 1\" } b = softwareSystem \"B\" c = softwareSystem \"C\" a -> b b -> c } views { systemLandscape { include * autolayout lr } styles { element \"Tag 1\" { background #1168bd color #ffffff shape RoundedBox } } } } Notes Please note that element styles are designed to work with the Structurizr cloud service/on-premises installation, and may not be fully supported by the PlantUML, Mermaid, etc export formats. DSL language reference - styles - element","title":"Element styles"},{"location":"cookbook/element-styles/#element-styles","text":"By default all elements are styled as grey boxes.","title":"Element styles"},{"location":"cookbook/element-styles/#styling-all-elements","text":"To change the style for all elements, add an element style for the Element tag. workspace { model { a = softwareSystem \"A\" b = softwareSystem \"B\" c = softwareSystem \"C\" a -> b b -> c } views { systemLandscape { include * autolayout lr } styles { element \"Element\" { background #1168bd color #ffffff shape RoundedBox } } } }","title":"Styling all elements"},{"location":"cookbook/element-styles/#styling-individual-elements","text":"To change the style of an individual element: Tag the element. Add an element style for that tag. workspace { model { a = softwareSystem \"A\" { tags \"Tag 1\" } b = softwareSystem \"B\" c = softwareSystem \"C\" a -> b b -> c } views { systemLandscape { include * autolayout lr } styles { element \"Tag 1\" { background #1168bd color #ffffff shape RoundedBox } } } }","title":"Styling individual elements"},{"location":"cookbook/element-styles/#notes","text":"Please note that element styles are designed to work with the Structurizr cloud service/on-premises installation, and may not be fully supported by the PlantUML, Mermaid, etc export formats. DSL language reference - styles - element","title":"Notes"},{"location":"cookbook/filtered-view/","text":"Filtered view A filtered view represents \"a view on top of another view\", which can be used to filter ( include or exclude ) specific elements and/or relationships, based upon their tag. Consider the following workspace definition: workspace { model { a = softwareSystem \"A\" { tags \"Tag 1\" } b = softwareSystem \"B\" { tags \"Tag 2\" } c = softwareSystem \"C\" { tags \"Tag 3\" } a -> b b -> c } views { systemLandscape \"landscape\" { include * autolayout lr } } } This DSL defines three software systems with relationships between them, and a system landscape view showing those software systems. The filtered view feature can be used to define views on top of this system landscape view. For example, the following DSL defines two filtered views: workspace { model { a = softwareSystem \"A\" { tags \"Tag 1\" } b = softwareSystem \"B\" { tags \"Tag 2\" } c = softwareSystem \"C\" { tags \"Tag 3\" } a -> b b -> c } views { systemLandscape \"landscape\" { include * autolayout lr } filtered \"landscape\" include \"Tag 1,Tag 2,Relationship\" \"landscape1\" filtered \"landscape\" exclude \"Tag 1\" \"landscape2\" } } The first of these filtered views includes all elements/relationships that are tagged Tag 1 , Tag 2 , or Relationship . filtered \"landscape\" include \"Tag 1,Tag 2,Relationship\" \"landscape1\" And the second excludes all elements/relationships that are tagged Tag 1 . filtered \"landscape\" exclude \"Tag 1\" \"landscape2\" When using filtered views, you'll notice that the original \"base view\" no longer shows in the list of viewable diagrams. This is by design. If you'd like to see the base view, you will need to create another filtered view that shows all elements and relationships. For example: filtered \"landscape\" include \"Element,Relationship\" \"landscape-all\" Links DSL language reference - filtered","title":"Filtered view"},{"location":"cookbook/filtered-view/#filtered-view","text":"A filtered view represents \"a view on top of another view\", which can be used to filter ( include or exclude ) specific elements and/or relationships, based upon their tag. Consider the following workspace definition: workspace { model { a = softwareSystem \"A\" { tags \"Tag 1\" } b = softwareSystem \"B\" { tags \"Tag 2\" } c = softwareSystem \"C\" { tags \"Tag 3\" } a -> b b -> c } views { systemLandscape \"landscape\" { include * autolayout lr } } } This DSL defines three software systems with relationships between them, and a system landscape view showing those software systems. The filtered view feature can be used to define views on top of this system landscape view. For example, the following DSL defines two filtered views: workspace { model { a = softwareSystem \"A\" { tags \"Tag 1\" } b = softwareSystem \"B\" { tags \"Tag 2\" } c = softwareSystem \"C\" { tags \"Tag 3\" } a -> b b -> c } views { systemLandscape \"landscape\" { include * autolayout lr } filtered \"landscape\" include \"Tag 1,Tag 2,Relationship\" \"landscape1\" filtered \"landscape\" exclude \"Tag 1\" \"landscape2\" } } The first of these filtered views includes all elements/relationships that are tagged Tag 1 , Tag 2 , or Relationship . filtered \"landscape\" include \"Tag 1,Tag 2,Relationship\" \"landscape1\" And the second excludes all elements/relationships that are tagged Tag 1 . filtered \"landscape\" exclude \"Tag 1\" \"landscape2\" When using filtered views, you'll notice that the original \"base view\" no longer shows in the list of viewable diagrams. This is by design. If you'd like to see the base view, you will need to create another filtered view that shows all elements and relationships. For example: filtered \"landscape\" include \"Element,Relationship\" \"landscape-all\"","title":"Filtered view"},{"location":"cookbook/filtered-view/#links","text":"DSL language reference - filtered","title":"Links"},{"location":"cookbook/implied-relationships/","text":"Implied relationships By default, the Structurizr DSL will create \"implied relationships\" automatically. For example, consider the following DSL, which defines a relationship between a person and a container. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" } u -> webapp \"Uses\" } views { systemContext s { include * autoLayout lr } } } Although the DSL does not define an explicit relationship between the person and the software system, this relationship is implied because of the relationship between the person and the container that resides inside the software system. Disabling implied relationships This functionality can be disabled using the !impliedRelationships keyword. For example: workspace { !impliedRelationships false model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" } u -> webapp \"Uses\" } views { systemContext s { include u s autoLayout } } } With the implied relationships functionality disabled, you will need to explicitly define every relationship that you want to see on your diagrams. Multiple implied relationships The Structurizr DSL uses the CreateImpliedRelationshipsUnlessAnyRelationshipExistsStrategy from the Java client library when creating implied relationships, which prevents multiple implied relationships from being created. For example, the following DSL will only create a single implied relationship between the person and the software system (the first that is defined in the DSL). workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" } u -> webapp \"Uses 1\" u -> webapp \"Uses 2\" } views { systemContext s { include * autoLayout lr } } } To show both relationships, you will need to explitly define them, as follows: workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" } u -> s \"Uses 1\" u -> s \"Uses 2\" u -> webapp \"Uses 1\" u -> webapp \"Uses 2\" } views { systemContext s { include * autoLayout lr } } } A better approach is to collapse multiple relationships into a single description, modelling the summary of all relationships rather than each individual relationship. This leads to less cluttered diagrams. See Modelling multiple relationships for more on this topic. Links DSL language reference - !impliedRelationships","title":"Implied relationships"},{"location":"cookbook/implied-relationships/#implied-relationships","text":"By default, the Structurizr DSL will create \"implied relationships\" automatically. For example, consider the following DSL, which defines a relationship between a person and a container. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" } u -> webapp \"Uses\" } views { systemContext s { include * autoLayout lr } } } Although the DSL does not define an explicit relationship between the person and the software system, this relationship is implied because of the relationship between the person and the container that resides inside the software system.","title":"Implied relationships"},{"location":"cookbook/implied-relationships/#disabling-implied-relationships","text":"This functionality can be disabled using the !impliedRelationships keyword. For example: workspace { !impliedRelationships false model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" } u -> webapp \"Uses\" } views { systemContext s { include u s autoLayout } } } With the implied relationships functionality disabled, you will need to explicitly define every relationship that you want to see on your diagrams.","title":"Disabling implied relationships"},{"location":"cookbook/implied-relationships/#multiple-implied-relationships","text":"The Structurizr DSL uses the CreateImpliedRelationshipsUnlessAnyRelationshipExistsStrategy from the Java client library when creating implied relationships, which prevents multiple implied relationships from being created. For example, the following DSL will only create a single implied relationship between the person and the software system (the first that is defined in the DSL). workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" } u -> webapp \"Uses 1\" u -> webapp \"Uses 2\" } views { systemContext s { include * autoLayout lr } } } To show both relationships, you will need to explitly define them, as follows: workspace { model { u = person \"User\" s = softwareSystem \"Software System\" { webapp = container \"Web Application\" } u -> s \"Uses 1\" u -> s \"Uses 2\" u -> webapp \"Uses 1\" u -> webapp \"Uses 2\" } views { systemContext s { include * autoLayout lr } } } A better approach is to collapse multiple relationships into a single description, modelling the summary of all relationships rather than each individual relationship. This leads to less cluttered diagrams. See Modelling multiple relationships for more on this topic.","title":"Multiple implied relationships"},{"location":"cookbook/implied-relationships/#links","text":"DSL language reference - !impliedRelationships","title":"Links"},{"location":"cookbook/introduction/","text":"Introduction Creating software architecture diagrams from text is becoming more popular. Text is easy to work with, and it's version controllable, so it can be stored alongside your source code. Tools like PlantUML , Mermaid , and WebSequenceDiagrams have auto-layout algorithms that allow us to focus on content too. In conjunction with the C4 model , it's relatively straightforward to create a collection of diagrams to describe the project/product you're working on, at different levels of abstraction. For example, here's a System Context diagram to describe a pet clinic information management system. And here's a Container diagram showing the internals of the software system. But wait! Did you spot the two errors in the Container diagram? Let's look at the diagrams next to each other. \"Clinic Employee\" has changed to \"Clinic Staff\". The arrow style has changed from dashed to solid. Granted these are only minor differences, but the problem here is one of consistency. If you're defining two diagrams in two separate text files, it's easy to make mistakes. Also, perhaps we wanted to change the name of the user from \"Clinic Employee\" to \"Clinic Staff\", but we forgot to change both files or regenerate them both. Some of these problems can be partially solved with the global search and replace tooling we have at our disposal as software developers. And some problems can be solved by integrating the diagram generation process into a CI/CD pipeline. But there's a better way. Make models, not diagrams What we're missing here is a single definition of the elements and relationships across all of our diagrams. When writing code, we often talk about DRY ( Don't repeat yourself ), where we try to avoid unnecessary duplication through copy-pasting code. That's exactly how many people create their diagrams though, by copy-pasting diagram definition fragments. PlantUML does support the concept of an !include directive to include fragments, but this can become complicated. What we really want to do is create a model of our software architecture, and then visualise it from different angles. The Structurizr DSL is an open source project that lets you do just this. Instead of writing two separate PlantUML files, we can define everything in a single file as follows. workspace { model { clinicEmployee = person \"Clinic Employee\" springPetClinic = softwareSystem \"Spring PetClinic\"{ webApplication = container \"Web Application\" database = container \"Database\" } clinicEmployee -> webApplication \"Uses\" webApplication -> database \"Reads from and writes to\" } views { systemContext springPetClinic { include * autolayout } container springPetClinic { include * autolayout } } } View this example online This text defines a model containing: a user, a software system, two containers, and the relationships between everything. It also then defines two views of this model: one System Context view, and one Container view. The DSL is a way to define software architecture models and views, but we still need a way to visualise that, and ultimately get some diagrams. We can do this with the Structurizr CLI , another open source project that has a number of features. ./structurizr.sh export -workspace example.dsl -format plantuml Running the Structurizr CLI in this way will create two .puml files, which we can then render with PlantUML in the normal way. Because both diagrams are created from the same model, they remain in sync, both from a content and a presentation perspective. Changes can now be made to the original DSL source file, and the diagrams regenerated.","title":"Introduction"},{"location":"cookbook/introduction/#introduction","text":"Creating software architecture diagrams from text is becoming more popular. Text is easy to work with, and it's version controllable, so it can be stored alongside your source code. Tools like PlantUML , Mermaid , and WebSequenceDiagrams have auto-layout algorithms that allow us to focus on content too. In conjunction with the C4 model , it's relatively straightforward to create a collection of diagrams to describe the project/product you're working on, at different levels of abstraction. For example, here's a System Context diagram to describe a pet clinic information management system. And here's a Container diagram showing the internals of the software system.","title":"Introduction"},{"location":"cookbook/introduction/#but-wait","text":"Did you spot the two errors in the Container diagram? Let's look at the diagrams next to each other. \"Clinic Employee\" has changed to \"Clinic Staff\". The arrow style has changed from dashed to solid. Granted these are only minor differences, but the problem here is one of consistency. If you're defining two diagrams in two separate text files, it's easy to make mistakes. Also, perhaps we wanted to change the name of the user from \"Clinic Employee\" to \"Clinic Staff\", but we forgot to change both files or regenerate them both. Some of these problems can be partially solved with the global search and replace tooling we have at our disposal as software developers. And some problems can be solved by integrating the diagram generation process into a CI/CD pipeline. But there's a better way.","title":"But wait!"},{"location":"cookbook/introduction/#make-models-not-diagrams","text":"What we're missing here is a single definition of the elements and relationships across all of our diagrams. When writing code, we often talk about DRY ( Don't repeat yourself ), where we try to avoid unnecessary duplication through copy-pasting code. That's exactly how many people create their diagrams though, by copy-pasting diagram definition fragments. PlantUML does support the concept of an !include directive to include fragments, but this can become complicated. What we really want to do is create a model of our software architecture, and then visualise it from different angles. The Structurizr DSL is an open source project that lets you do just this. Instead of writing two separate PlantUML files, we can define everything in a single file as follows. workspace { model { clinicEmployee = person \"Clinic Employee\" springPetClinic = softwareSystem \"Spring PetClinic\"{ webApplication = container \"Web Application\" database = container \"Database\" } clinicEmployee -> webApplication \"Uses\" webApplication -> database \"Reads from and writes to\" } views { systemContext springPetClinic { include * autolayout } container springPetClinic { include * autolayout } } } View this example online This text defines a model containing: a user, a software system, two containers, and the relationships between everything. It also then defines two views of this model: one System Context view, and one Container view. The DSL is a way to define software architecture models and views, but we still need a way to visualise that, and ultimately get some diagrams. We can do this with the Structurizr CLI , another open source project that has a number of features. ./structurizr.sh export -workspace example.dsl -format plantuml Running the Structurizr CLI in this way will create two .puml files, which we can then render with PlantUML in the normal way. Because both diagrams are created from the same model, they remain in sync, both from a content and a presentation perspective. Changes can now be made to the original DSL source file, and the diagrams regenerated.","title":"Make models, not diagrams"},{"location":"cookbook/perspectives/","text":"Perspectives Structurizr supports the concept of \"perspectives\" from viewpoints and perspectives , where you want to look at a diagram with a view to answering a particular question. Perhaps you have a system landscape diagram showing software systems, and you'd like to see the ownership of each software system. Or perhaps you have a container diagram, and you'd like to see details of how each container satisifies the security requirements. Perspectives can be added to any model element or relationship; for example: workspace { model { a = softwareSystem \"A\" { perspectives { \"Ownership\" \"Team 1\" } } b = softwareSystem \"B\" { perspectives { \"Ownership\" \"Team 2\" } } } views { systemLandscape { include * autoLayout } } } This DSL defines an \"Ownership\" perspective for each software system, which can be viewed by following the instructions at Structurizr - Help - Perspectives . Links DSL language reference - perspectives","title":"Perspectives"},{"location":"cookbook/perspectives/#perspectives","text":"Structurizr supports the concept of \"perspectives\" from viewpoints and perspectives , where you want to look at a diagram with a view to answering a particular question. Perhaps you have a system landscape diagram showing software systems, and you'd like to see the ownership of each software system. Or perhaps you have a container diagram, and you'd like to see details of how each container satisifies the security requirements. Perspectives can be added to any model element or relationship; for example: workspace { model { a = softwareSystem \"A\" { perspectives { \"Ownership\" \"Team 1\" } } b = softwareSystem \"B\" { perspectives { \"Ownership\" \"Team 2\" } } } views { systemLandscape { include * autoLayout } } } This DSL defines an \"Ownership\" perspective for each software system, which can be viewed by following the instructions at Structurizr - Help - Perspectives .","title":"Perspectives"},{"location":"cookbook/perspectives/#links","text":"DSL language reference - perspectives","title":"Links"},{"location":"cookbook/relationship-styles/","text":"Relationship styles By default all relationships are styled as dashed grey lines. Styling all relationships To change the style for all relationships, add a relationship style for the Relationship tag. workspace { model { a = softwareSystem \"A\" b = softwareSystem \"B\" c = softwareSystem \"C\" a -> b b -> c } views { systemLandscape { include * autolayout lr } styles { relationship \"Relationship\" { color #ff0000 dashed false } } } } Styling individual relationships To change the style of an individual relationship: Tag the relationship. Add a relationship style for that tag. workspace { model { a = softwareSystem \"A\" b = softwareSystem \"B\" c = softwareSystem \"C\" a -> b b -> c { tags \"Tag 1\" } } views { systemLandscape { include * autolayout lr } styles { relationship \"Tag 1\" { color #ff0000 dashed false } } } } Notes Please note that relationship styles are designed to work with the Structurizr cloud service/on-premises installation, and may not be fully supported by the PlantUML, Mermaid, etc export formats. DSL language reference - styles - relationship","title":"Relationship styles"},{"location":"cookbook/relationship-styles/#relationship-styles","text":"By default all relationships are styled as dashed grey lines.","title":"Relationship styles"},{"location":"cookbook/relationship-styles/#styling-all-relationships","text":"To change the style for all relationships, add a relationship style for the Relationship tag. workspace { model { a = softwareSystem \"A\" b = softwareSystem \"B\" c = softwareSystem \"C\" a -> b b -> c } views { systemLandscape { include * autolayout lr } styles { relationship \"Relationship\" { color #ff0000 dashed false } } } }","title":"Styling all relationships"},{"location":"cookbook/relationship-styles/#styling-individual-relationships","text":"To change the style of an individual relationship: Tag the relationship. Add a relationship style for that tag. workspace { model { a = softwareSystem \"A\" b = softwareSystem \"B\" c = softwareSystem \"C\" a -> b b -> c { tags \"Tag 1\" } } views { systemLandscape { include * autolayout lr } styles { relationship \"Tag 1\" { color #ff0000 dashed false } } } }","title":"Styling individual relationships"},{"location":"cookbook/relationship-styles/#notes","text":"Please note that relationship styles are designed to work with the Structurizr cloud service/on-premises installation, and may not be fully supported by the PlantUML, Mermaid, etc export formats. DSL language reference - styles - relationship","title":"Notes"},{"location":"cookbook/scripts/","text":"Scripts The !script keyword provides a way to run scripts written in Groovy, Kotlin, Ruby, and JavaScript. This gives you access to the underlying Structurizr for Java workspace object via a variable named workspace , for when you need to do something not supported by the DSL. Here are some useful scripts. Create the default views, without automatic layout !script groovy { workspace.views.createDefaultViews() workspace.views.views.each { it.disableAutomaticLayout() } } Programmatically add elements to a view workspace { model { group \"Group 1\" { a = softwareSystem \"A\" { tags \"Tag 1\" } b = softwareSystem \"B\" { tags \"Tag 2\" } } group \"Group 2\" { c = softwareSystem \"C\" { tags \"Tag 1\" } d = softwareSystem \"D\" { tags \"Tag 2\" } } } views { systemLandscape \"key\" { !script groovy { view = workspace.views.getViewWithKey(\"key\"); workspace.model.softwareSystems.findAll { it.group == \"Group 1\" && it.hasTag(\"Tag 1\") }.each{ view.add(it); }; } autolayout } } } Run Graphviz locally !script groovy { new com.structurizr.graphviz.GraphvizAutomaticLayout().apply(workspace); } (this requires Graphviz to be installed locally) Links DSL language reference - !script Structurizr for Java source code","title":"Scripts"},{"location":"cookbook/scripts/#scripts","text":"The !script keyword provides a way to run scripts written in Groovy, Kotlin, Ruby, and JavaScript. This gives you access to the underlying Structurizr for Java workspace object via a variable named workspace , for when you need to do something not supported by the DSL. Here are some useful scripts.","title":"Scripts"},{"location":"cookbook/scripts/#create-the-default-views-without-automatic-layout","text":"!script groovy { workspace.views.createDefaultViews() workspace.views.views.each { it.disableAutomaticLayout() } }","title":"Create the default views, without automatic layout"},{"location":"cookbook/scripts/#programmatically-add-elements-to-a-view","text":"workspace { model { group \"Group 1\" { a = softwareSystem \"A\" { tags \"Tag 1\" } b = softwareSystem \"B\" { tags \"Tag 2\" } } group \"Group 2\" { c = softwareSystem \"C\" { tags \"Tag 1\" } d = softwareSystem \"D\" { tags \"Tag 2\" } } } views { systemLandscape \"key\" { !script groovy { view = workspace.views.getViewWithKey(\"key\"); workspace.model.softwareSystems.findAll { it.group == \"Group 1\" && it.hasTag(\"Tag 1\") }.each{ view.add(it); }; } autolayout } } }","title":"Programmatically add elements to a view"},{"location":"cookbook/scripts/#run-graphviz-locally","text":"!script groovy { new com.structurizr.graphviz.GraphvizAutomaticLayout().apply(workspace); } (this requires Graphviz to be installed locally)","title":"Run Graphviz locally"},{"location":"cookbook/scripts/#links","text":"DSL language reference - !script Structurizr for Java source code","title":"Links"},{"location":"cookbook/system-context-view/","text":"System Context view A system context view is a good starting point for diagramming and documenting a software system, allowing you to step back and see the big picture. It shows the software system in the centre, surrounded by its users and the other systems that it interacts with. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" u -> s \"Uses\" } views { systemContext s { include * autoLayout lr } } } This DSL defines a system context view for the software system s , and include * includes all model elements that have a direct relationship with it. System context views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command . Links DSL language reference - systemContext","title":"System Context view"},{"location":"cookbook/system-context-view/#system-context-view","text":"A system context view is a good starting point for diagramming and documenting a software system, allowing you to step back and see the big picture. It shows the software system in the centre, surrounded by its users and the other systems that it interacts with. workspace { model { u = person \"User\" s = softwareSystem \"Software System\" u -> s \"Uses\" } views { systemContext s { include * autoLayout lr } } } This DSL defines a system context view for the software system s , and include * includes all model elements that have a direct relationship with it. System context views can be rendered using the Structurizr cloud service/on-premises installation or exported to a number of other formats via the Structurizr CLI export command .","title":"System Context view"},{"location":"cookbook/system-context-view/#links","text":"DSL language reference - systemContext","title":"Links"},{"location":"cookbook/themes/","text":"Themes Some pre-built themes are available to help you diagram deployment architectures that make use of popular cloud providers such as Amazon Web Services, Microsoft Azure, Google Cloud Platform, etc. Links to these themes can be found at Structurizr - Help - Themes . You can also create your own themes. What is a theme? A theme is a JSON file consisting of one or more element/relationship styles that are defined for specific tags. Themes need to be hosted at a publicly accessible URL, and hosted over HTTPS if you're using the Structurizr cloud service. For example, a pre-built Microsoft Azure theme can be found at the following URL: https://static.structurizr.com/themes/microsoft-azure-2021.01.26/theme.json You can use the Structurizr theme browser to view the styles that are defined in the theme, with the following URL: https://structurizr.com/help/theme?url=https://static.structurizr.com/themes/microsoft-azure-2021.01.26/theme.json Using a theme The theme or themes keywords can be used to include one or more themes in your workspace. You will also need to add the appropriate tags to your model elements/relationships. workspace { model { softwareSystem \"Authentication Service\" { tags \"Microsoft Azure - Azure Active Directory\" } } views { systemLandscape { include * autoLayout lr } theme https://static.structurizr.com/themes/microsoft-azure-2021.01.26/theme.json } } For further customisation, themes can be used in conjunction with element/relationship styles that are defined in the workspace. workspace { model { softwareSystem \"Authentication Service\" { tags \"Microsoft Azure - Azure Active Directory\" } } views { systemLandscape { include * autoLayout lr } styles { element \"Software System\" { background #ffffff shape RoundedBox } } theme https://static.structurizr.com/themes/microsoft-azure-2021.01.26/theme.json } } Notes Please note that themes are designed to work with the Structurizr cloud service/on-premises installation/Lite, and may not be fully supported by the PlantUML, Mermaid, etc export formats. DSL language reference - theme DSL language reference - themes","title":"Themes"},{"location":"cookbook/themes/#themes","text":"Some pre-built themes are available to help you diagram deployment architectures that make use of popular cloud providers such as Amazon Web Services, Microsoft Azure, Google Cloud Platform, etc. Links to these themes can be found at Structurizr - Help - Themes . You can also create your own themes.","title":"Themes"},{"location":"cookbook/themes/#what-is-a-theme","text":"A theme is a JSON file consisting of one or more element/relationship styles that are defined for specific tags. Themes need to be hosted at a publicly accessible URL, and hosted over HTTPS if you're using the Structurizr cloud service. For example, a pre-built Microsoft Azure theme can be found at the following URL: https://static.structurizr.com/themes/microsoft-azure-2021.01.26/theme.json You can use the Structurizr theme browser to view the styles that are defined in the theme, with the following URL: https://structurizr.com/help/theme?url=https://static.structurizr.com/themes/microsoft-azure-2021.01.26/theme.json","title":"What is a theme?"},{"location":"cookbook/themes/#using-a-theme","text":"The theme or themes keywords can be used to include one or more themes in your workspace. You will also need to add the appropriate tags to your model elements/relationships. workspace { model { softwareSystem \"Authentication Service\" { tags \"Microsoft Azure - Azure Active Directory\" } } views { systemLandscape { include * autoLayout lr } theme https://static.structurizr.com/themes/microsoft-azure-2021.01.26/theme.json } } For further customisation, themes can be used in conjunction with element/relationship styles that are defined in the workspace. workspace { model { softwareSystem \"Authentication Service\" { tags \"Microsoft Azure - Azure Active Directory\" } } views { systemLandscape { include * autoLayout lr } styles { element \"Software System\" { background #ffffff shape RoundedBox } } theme https://static.structurizr.com/themes/microsoft-azure-2021.01.26/theme.json } }","title":"Using a theme"},{"location":"cookbook/themes/#notes","text":"Please note that themes are designed to work with the Structurizr cloud service/on-premises installation/Lite, and may not be fully supported by the PlantUML, Mermaid, etc export formats. DSL language reference - theme DSL language reference - themes","title":"Notes"},{"location":"cookbook/workspace/","text":"Workspace In Structurizr terminology, a \"workspace\" is a wrapper for a software architecture model (elements and relationships) and views. workspace \"Name\" \"Description\" { model { } views { } } A workspace can be given a name and description, although these are only used by the Structurizr cloud service and on-premises installation - you don't need to specify a name/description if you're exporting views to one of the export formats (PlantUML, Mermaid, etc). Links DSL language reference - workspace Example","title":"Workspace"},{"location":"cookbook/workspace/#workspace","text":"In Structurizr terminology, a \"workspace\" is a wrapper for a software architecture model (elements and relationships) and views. workspace \"Name\" \"Description\" { model { } views { } } A workspace can be given a name and description, although these are only used by the Structurizr cloud service and on-premises installation - you don't need to specify a name/description if you're exporting views to one of the export formats (PlantUML, Mermaid, etc).","title":"Workspace"},{"location":"cookbook/workspace/#links","text":"DSL language reference - workspace Example","title":"Links"},{"location":"cookbook/workspace-extension/","text":"Workspace extension The Structurizr DSL provides a way to extend an existing workspace, enabling you to reuse common elements/relationships across multiple workspaces. To use this feature, define your workspace as normal. For example: workspace { !identifiers hierarchical model { a = softwareSystem \"A\" b = softwareSystem \"B\" a -> b \"Gets data X from\" } } Next, define your child workspace, using the extends keyword to specify the workspace that should be extended. For example: workspace extends https://raw.githubusercontent.com/structurizr/dsl/master/docs/cookbook/workspace-extension/system-landscape.dsl { model { !ref a { webapp = container \"Web Application\" database = container \"Database\" webapp -> b \"Gets data X from\" webapp -> database \"Reads from and writes to\" } } views { systemContext a \"A-SystemContext\" { include * autolayout lr } container a \"A-Containers\" { include * autolayout } } } In this example we're extending a workspace that's accessible via a public URL, but you can also specify the name of a local file. We can use the !ref keyword to reference and extend the existing software system named \"A\", which is identified in the parent workspace as a . Since b is already defined in the parent workspace, we can reference it from the child workspace as if it was defined locally. This will create a system context diagram: And a container diagram: Links DSL language reference - workspace DSL language reference - ref","title":"Workspace extension"},{"location":"cookbook/workspace-extension/#workspace-extension","text":"The Structurizr DSL provides a way to extend an existing workspace, enabling you to reuse common elements/relationships across multiple workspaces. To use this feature, define your workspace as normal. For example: workspace { !identifiers hierarchical model { a = softwareSystem \"A\" b = softwareSystem \"B\" a -> b \"Gets data X from\" } } Next, define your child workspace, using the extends keyword to specify the workspace that should be extended. For example: workspace extends https://raw.githubusercontent.com/structurizr/dsl/master/docs/cookbook/workspace-extension/system-landscape.dsl { model { !ref a { webapp = container \"Web Application\" database = container \"Database\" webapp -> b \"Gets data X from\" webapp -> database \"Reads from and writes to\" } } views { systemContext a \"A-SystemContext\" { include * autolayout lr } container a \"A-Containers\" { include * autolayout } } } In this example we're extending a workspace that's accessible via a public URL, but you can also specify the name of a local file. We can use the !ref keyword to reference and extend the existing software system named \"A\", which is identified in the parent workspace as a . Since b is already defined in the parent workspace, we can reference it from the child workspace as if it was defined locally. This will create a system context diagram: And a container diagram:","title":"Workspace extension"},{"location":"cookbook/workspace-extension/#links","text":"DSL language reference - workspace DSL language reference - ref","title":"Links"},{"location":"language-reference/","text":"Language Reference The Structurizr DSL provides a way to define a software architecture model (based upon the C4 model ) as text, using a domain specific language (DSL). The Structurizr CLI (command line interface) provides tooling to parse DSL workspace definitions, upload them to the Structurizr cloud service/on-premises installation, and export diagrams to other formats (e.g. PlantUML and WebSequenceDiagrams). See https://structurizr.com/dsl for a demo of the DSL. Please note that what you see here may not be available in the Structurizr CLI yet, but it will likely be available on the Structurizr DSL demo page .","title":"Intro"},{"location":"language-reference/#language-reference","text":"The Structurizr DSL provides a way to define a software architecture model (based upon the C4 model ) as text, using a domain specific language (DSL). The Structurizr CLI (command line interface) provides tooling to parse DSL workspace definitions, upload them to the Structurizr cloud service/on-premises installation, and export diagrams to other formats (e.g. PlantUML and WebSequenceDiagrams). See https://structurizr.com/dsl for a demo of the DSL. Please note that what you see here may not be available in the Structurizr CLI yet, but it will likely be available on the Structurizr DSL demo page .","title":"Language Reference"},{"location":"language-reference/comments/","text":"Comments Comments can be defined as follows: /* multi-line comment */ /* single-line comment */ # single line comment // single line comment","title":"Comments"},{"location":"language-reference/comments/#comments","text":"Comments can be defined as follows: /* multi-line comment */ /* single-line comment */ # single line comment // single line comment","title":"Comments"},{"location":"language-reference/constant/","text":"Constants The !constant keyword can be used to define a constant, which can be used with string substitution !constant <name> <value> Constant names may only contain the following characters: a-zA-Z0-9-_.","title":"Constants"},{"location":"language-reference/constant/#constants","text":"The !constant keyword can be used to define a constant, which can be used with string substitution !constant <name> <value> Constant names may only contain the following characters: a-zA-Z0-9-_.","title":"Constants"},{"location":"language-reference/expressions/","text":"Expressions The Structurizr DSL supports a number of expressions for use when including or excluding elements/relationships on views. -><identifier|expression> : the specified element(s) plus afferent couplings <identifier|expression>-> : the specified element(s) plus efferent couplings -><identifier|expression>-> : the specified element(s) plus afferent and efferent couplings element.type==<type> : elements of the specified type (Person|SoftwareSystem|Container|Component|DeploymentNode|InfrastructureNode|SoftwareSystemInstance|ContainerInstance|Custom) element.parent==<identifier> : elements with the specified parent element.tag==<tag>[,tag] : all elements that have all of the specified tags element.tag!=<tag>[,tag] : all elements that do not have all of the specified tags element==-><identifier> : the specified element plus afferent couplings element==<identifier>-> : the specified element plus efferent couplings element==-><identifier>-> : the specified element plus afferent and efferent couplings *->* : all relationships <identifier>->* : all relationships with the specified source element *-><identifier> : all relationships with the specified destination element relationship==* : all relationships relationship==*->* : all relationships relationship.tag==<tag>[,tag] : all relationships that have all of the specified tags relationship.tag!=<tag>[,tag] : all relationships that do not have all of the specified tags relationship.source==<identifier> : all relationships with the specified source element relationship.destination==<identifier> : all relationships with the specified destination element relationship==<identifier>->* : all relationships with the specified source element relationship==*-><identifier> : all relationships with the specified destination element relationship==<identifier>-><identifier> : all relationships between the two specified elements Element and relationship expressions are not supported on dynamic views.","title":"Expressions"},{"location":"language-reference/expressions/#expressions","text":"The Structurizr DSL supports a number of expressions for use when including or excluding elements/relationships on views. -><identifier|expression> : the specified element(s) plus afferent couplings <identifier|expression>-> : the specified element(s) plus efferent couplings -><identifier|expression>-> : the specified element(s) plus afferent and efferent couplings element.type==<type> : elements of the specified type (Person|SoftwareSystem|Container|Component|DeploymentNode|InfrastructureNode|SoftwareSystemInstance|ContainerInstance|Custom) element.parent==<identifier> : elements with the specified parent element.tag==<tag>[,tag] : all elements that have all of the specified tags element.tag!=<tag>[,tag] : all elements that do not have all of the specified tags element==-><identifier> : the specified element plus afferent couplings element==<identifier>-> : the specified element plus efferent couplings element==-><identifier>-> : the specified element plus afferent and efferent couplings *->* : all relationships <identifier>->* : all relationships with the specified source element *-><identifier> : all relationships with the specified destination element relationship==* : all relationships relationship==*->* : all relationships relationship.tag==<tag>[,tag] : all relationships that have all of the specified tags relationship.tag!=<tag>[,tag] : all relationships that do not have all of the specified tags relationship.source==<identifier> : all relationships with the specified source element relationship.destination==<identifier> : all relationships with the specified destination element relationship==<identifier>->* : all relationships with the specified source element relationship==*-><identifier> : all relationships with the specified destination element relationship==<identifier>-><identifier> : all relationships between the two specified elements Element and relationship expressions are not supported on dynamic views.","title":"Expressions"},{"location":"language-reference/general-rules/","text":"General Rules Line breaks are important. Lines are processed in order. Tokens must be separated by whitespace, but the quantity of whitespace/indentation isn't important. Keywords are case-insensitive (e.g. you can use softwareSystem or softwaresystem ). Double quote characters ( \"...\" ) are optional when a property/expression contains no whitespace. Opening curly brace symbols ( { ) must be on the same line (i.e. the last token of the statement, not on a line of their own). Closing curly brace symbols ( } ) must be on a line of their own. Opening/closing braces are only required when adding child content. Use \"\" as a placeholder for an earlier optional property that you'd like to skip. Tags are comma separated (e.g. Tag 1,Tag 2,Tag 3 ) - see Structurizr - Notation for details of how tags and styling works. The Structurizr CLI will provide some default views and styles when they are not specified in your DSL - see Structurizr CLI - Defaults for details. In addition, workspaces are subject to the following rules: Each view must have a unique \"key\" (this is autogenerated if not specified). Software and people names must be unique. Container names must be unique within the context of a software system. Component names must be unique within the context of a container. Deployment node names must be unique with their parent context. Infrastructure node names must be unique with their parent context. All relationships from a source element to a destination element must have a unique description.","title":"General Rules"},{"location":"language-reference/general-rules/#general-rules","text":"Line breaks are important. Lines are processed in order. Tokens must be separated by whitespace, but the quantity of whitespace/indentation isn't important. Keywords are case-insensitive (e.g. you can use softwareSystem or softwaresystem ). Double quote characters ( \"...\" ) are optional when a property/expression contains no whitespace. Opening curly brace symbols ( { ) must be on the same line (i.e. the last token of the statement, not on a line of their own). Closing curly brace symbols ( } ) must be on a line of their own. Opening/closing braces are only required when adding child content. Use \"\" as a placeholder for an earlier optional property that you'd like to skip. Tags are comma separated (e.g. Tag 1,Tag 2,Tag 3 ) - see Structurizr - Notation for details of how tags and styling works. The Structurizr CLI will provide some default views and styles when they are not specified in your DSL - see Structurizr CLI - Defaults for details. In addition, workspaces are subject to the following rules: Each view must have a unique \"key\" (this is autogenerated if not specified). Software and people names must be unique. Container names must be unique within the context of a software system. Component names must be unique within the context of a container. Deployment node names must be unique with their parent context. Infrastructure node names must be unique with their parent context. All relationships from a source element to a destination element must have a unique description.","title":"General Rules"},{"location":"language-reference/grammar/","text":"Grammar The following describes the language grammar, with angle brackets ( <...> ) used to show required properties, and square brackets ( [...] ) used to show optional properties. Most statements are of the form: keyword <required properties> [optional properties] workspace workspace is the top level language construct, and the wrapper for the model and views . A workspace can optionally be given a name and description. workspace [name] [description] { ... } A workspace can also extend another workspace, to add more elements, relationships, views, etc to it. workspace extends <file|url> { ... } The base workspace can either be referenced using a local DSL/JSON file, or a remote (via a HTTPS URL) DSL/JSON file. When extending a DSL-based workspace, all of the identifiers defined in that workspace are available to use in the extended workspace. Permitted children: name description properties !docs !adrs !identifiers !impliedRelationships model views configuration model Each workspace must contain a model block, inside which elements and relationships are defined. model { ... } Permitted children: enterprise group person softwareSystem deploymentEnvironment element -> (relationship) enterprise The enterprise keyword provides a way to define a named \"enterprise\" (e.g. an organisation) within the top-level model. Any people or software systems defined inside this block will be deemed to be \"internal\", while all others will be deemed to be \"external\". On System Landscape and System Context diagrams, an enterprise is represented as a dashed box. Only a single enterprise can be defined within a model. enterprise [name] { ... } Permitted children: group person softwareSystem -> (relationship) group The group keyword provides a way to define a named grouping of elements, which will be rendered as a boundary around those elements. See groups.dsl for an example. group <name> { ... } Groups can be defined as follows: Location Permitted elements Model People and software systems Software System Containers Container Components Groups cannot be nested. person The person keyword defines a person (e.g. a user, actor, role, or persona). person <name> [description] [tags] { ... } The following tags are added by default: Element Person Permitted children: description tags url properties perspectives -> (relationship) softwareSystem The softwareSystem keyword defines a software system. softwareSystem <name> [description] [tags] { ... } The following tags are added by default: Element Software System Permitted children: group container !docs !adrs description tags url properties perspectives -> (relationship) container The container keyword defines a container, within a software system. container <name> [description] [technology] [tags] { ... } The following tags are added by default: Element Container Permitted children: group component description technology tags url properties perspectives -> (relationship) component The component keyword defines a component, within a container. component <name> [description] [technology] [tags] { ... } The following tags are added by default: Element Component Permitted children: description technology tags url properties perspectives -> (relationship) deploymentEnvironment The deploymentEnvironment keyword provides a way to define a deployment environment (e.g. development, testing, staging, live, etc). deploymentEnvironment <name> { ... } Permitted children: deploymentGroup deploymentNode -> (relationship) deploymentGroup The deploymentGroup keyword provides a way to define a named deployment group. deploymentGroup <name> When software system/container instances are added to a deployment environment, all of the relationships between these elements are automatically replicated between all instances. Deployment groups provide a way to restrict the scope in which relationships are replicated. See deployment-groups.dsl for an example. deploymentNode The deploymentNode keyword is used to define a deployment node. deploymentNode <name> [description] [technology] [tags] [instances] { ... } The following tags are added by default: Element Deployment Node Permitted children: deploymentNode (deployment nodes can be nested) infrastructureNode softwareSystemInstance containerInstance -> (relationship) description technology instances tags url properties perspectives infrastructureNode The infrastructureNode keyword defines an infrastructure node, which is typically something like a load balancer, firewall, DNS service, etc. infrastructureNode <name> [description] [technology] [tags] { ... } The following tags are added by default: Element Infrastructure Node Permitted children: -> (relationship) description technology tags url properties perspectives softwareSystemInstance The softwareSystemInstance keyword defines an instance of the specified software system that is deployed on the parent deployment node. softwareSystemInstance <identifier> [deploymentGroups] [tags] { ... } The identifier must represent a software system. deploymentGroups is a comma seperated list of identifiers representing deployment groups. In addition to the software system's tags, the following tags are added by default: Software System Instance Permitted children: -> (relationship) description tags url properties perspectives healthCheck containerInstance The containerInstance keyword defines an instance of the specified container that is deployed on the parent deployment node. containerInstance <identifier> [deploymentGroups] [tags] { ... } The identifier must represent a container. deploymentGroups is a comma seperated list of identifiers representing deployment groups. In addition to the container's tags, the following tags are added by default: Container Instance Permitted children: -> (relationship) description tags url properties perspectives healthCheck healthCheck The healthCheck keyword defines a HTTP health check for the parent software system/container instance. healthCheck <name> <url> [interval] [timeout] The interval is a number of seconds (default 60s), and the timeout is a number of milliseconds (default 0ms). element The element keyword defines a custom element (this is only available on the Structurizr cloud service/on-premises installation/Lite). element <name> [metadata] [description] [tags] { ... } The following tags are added by default: Element Permitted children: description tags url properties perspectives -> (relationship) relationship -> is used to define a uni-directional relationship between two elements. There are two ways to define relationships. The first is explicitly, where you explicitly use a source identifier: <identifier> -> <identifier> [description] [technology] [tags] { ... } For example: user -> softwareSystem \"Uses\" And the second is implicitly, where the relationship source is the element in scope: -> <identifier> [description] [technology] [tags] For example: person user { -> softwareSystem \"Uses\" } This is equivalent to the following, where the special this identifier is used to refer to the element in scope: person user { this -> softwareSystem \"Uses\" } The following tags are added to relationships by default: Relationship The following types of relationships can be created using the DSL: Source Destination Person Person, Software System, Container, Component Software System Person, Software System, Container, Component Container Person, Software System, Container, Component Component Person, Software System, Container, Component Deployment Node Deployment Node Infrastructure Node Deployment Node, Infrastructure Node, Software System Instance, Container Instance Software System Instance Infrastructure Node Container Instance Infrastructure Node Permitted children: tags url properties perspectives tags tags is used to add tags to an element or relationship. Tags can be specified comma separated, or individually. tags \"Tag 1\" tags \"Tag 1,Tag 2\" tags \"Tag 1\" \"Tag 2\" description description is used to set the description on an element or view. description \"Description\" technology technology is used to set the technology on a container, component, deployment node, infrastructure node. technology \"Technology\" instances instances is used to set the number of instances of a deployment node. instances \"4\" url url is used to set a URL on an element or relationship. url https://example.com properties The properties block is used to define one or more name/value properties. properties { <name> <value> ... } perspectives The perspectives block is used to define one or more name/description perspectives for an element or relationship. See Help - Perspectives for how these are used. perspectives { <name> <description> ... } !ref The !ref keyword provides a way to reference a previously defined element/relationship, and is designed to be used with the workspace extends or !include features. It can be used in a couple of ways. The first usage scenario is to reference an existing element/relationship that has been defined via the DSL. This allows you to extend the element referenced by the given identifier. !ref <identifier> { ... } Or, if you're extending a JSON-based workspace, you can reference an element by its \"canonical name\", and assign that to an identifier. <identifier> = !ref <canonical name> { ... } See ref.dsl for some usage examples. Please note that !ref is currently an experimental feature. views Each workspace can also contain one or more views, defined with the views block. views { ... } The views block can contain the following: systemLandscape systemContext container component filtered dynamic deployment custom styles theme themes branding terminology properties systemLandscape view The systemLandscape keyword is used to define a System Landscape view . systemLandscape [key] [description] { ... } Permitted children: include exclude autoLayout animation title description properties systemContext view The systemContext keyword is used to define a System Context view for the specified software system. systemContext <software system identifier> [key] [description] { ... } Permitted children: include exclude autoLayout animation title description properties container view The container keyword is used to define a Container view for the specified software system. container <software system identifier> [key] [description] { ... } Permitted children: include exclude autoLayout animation title description properties component view The component keyword is used to define a Component view for the specified container. component <container identifier> [key] [description] { ... } Permitted children: include exclude autoLayout animation title description properties filtered view The filtered keyword is used to define a Filtered view on top of the specified view. filtered <baseKey> <include|exclude> <tags> [key] [description] The baseKey specifies the key of the System Landscape, System Context, Container, or Component view on which this filtered view should be based. The mode ( include or exclude ) defines whether the view should include or exclude elements/relationships based upon the tags provided. Please note that once a filtered view is defined for a given \"base view\", that base view will no longer show up in your diagram list when using the Structurizr renderer. This is by design. If you'd like to see the base view too, just create another filtered view for the same base view, which includes the Element and Relationship tags. filtered <baseKey> include \"Element,Relationship\" [key] [description] dynamic view The dynamic keyword defines a Dynamic view for the specified scope. dynamic <*|software system identifier|container identifier> [key] [description] { ... } The first property defines the scope of the view, and therefore what can be added to the view, as follows: * scope: People and software systems. Software system scope: People, other software systems, and containers. Container scope: People, other software systems, other containers, and components. Unlike the other diagram types, Dynamic views are created by specifying the relationships that should be added to the view, within the dynamic block, as follows: <element identifier> -> <element identifier> [description] [technology] <relationship identifier> [description] With a dynamic view, you're showing instances of relationships that are defined in the static model. For example, imagine that you have two software systems defined in the static model, with a single relationship between them described as \"Sends data to\". A dynamic view allows you to override the relationship description, to better describe the interaction in the context of the behaviour you're diagramming. See dynamic.dsl for an example of this, and Modelling multiple relationships for some tips on how to best model multiple relationships between two elements in order to avoid cluttering your static model. For convenience, if a relationship between the two elements does not exist in the static model, the DSL parser will automatically create it for you. See parallel.dsl for an example of how to create dynamic diagrams with parallel sequences. Permitted children: autoLayout title description properties deployment view The deployment keyword defines a Deployment view for the specified scope and deployment environment. deployment <*|software system identifier> <environment> [key] [description] { ... } The first property defines the scope of the view, and the second property defines the deployment environment (which can be an identifier, or a name). The combination of these two properties determines what can be added to the view, as follows: * scope: All deployment nodes, infrastructure nodes, and container instances within the deployment environment. Software system scope: All deployment nodes and infrastructure nodes within the deployment environment. Container instances within the deployment environment that belong to the software system. Permitted children: include exclude autoLayout animation title description properties custom view The custom keyword is used to define a custom view (this is only available on the Structurizr cloud service/on-premises installation). custom [key] [title] [description] { ... } Permitted children: include exclude autoLayout animation title description properties include The include keyword can be used to include elements or relationships. Including elements To include elements in a view, use one or more include statements inside the block defining the view. include <*|identifier|expression> [*|identifier|expression...] Elements can either be specified using individual identifiers, the wildcard identifier ( * ), or a property expression. Please note that including elements will also include the relationships between those elements. The wildcard identifier ( * ) operates differently depending upon the type of diagram, as follows: System Landscape view: Include all people and software systems. System Context view: Include the software system in scope; plus all people and software systems that are directly connected to the software system in scope. Container view: Include all containers within the software system in scope; plus all people and software systems that are directly connected to those containers. Component view: Include all components within the container in scope; plus all people, software systems and containers (belonging to the software system in scope) directly connected to them. Filtered view: (not applicable) Dynamic view: (not applicable) Deployment view: Include all deployment nodes, infrastructure nodes, and container instances defined within the deployment environment and (optional) software system in scope. They provide a way to include elements based upon some basic conditional logic, as follows: element.tag==<tag>,[tag] : include elements that have all of the specified tags element.tag!=<tag>,[tag] : include elements that do not have all of the specified tags Including relationships To include a relationship in a view, you can specify an individual relationship identifier, or an expression: include <identifier|expression> [identifier|expression...] Relationship expressions only operate on elements that exist in the view. exclude The exclude keyword can be used to exclude elements or relationships. Excluding elements To exclude specific elements, use one or more exclude statements inside the block defining the view. exclude <identifier|expression> [identifier|expression...] Excluding relationships To exclude a relationship in a view, you can specify an individual relationship identifier, or use a property expression: exclude <identifier|expression> [identifier|expression...] They provide a way to exclude relationships based upon some basic conditional logic, as follows: relationship.tag==<tag>,[tag] : exclude relationships that have all of the specified tags relationship.tag!=<tag>,[tag] : exclude relationships that do not have all of the specified tags Alternatively, you can use the relationship expression syntax as follows (please note the double quotes surrounding the entire expression): exclude \"<*|identifier> -> <*|identifier>\" The combinations of parameters are: * -> * : all relationships between all elements source -> * : all relationships from source to any element * -> destination : all relationships from any element to destination source -> destination : all relationships from source to destination The relationship expression syntax only operates on elements that exist in the view. autoLayout To enable automatic layout mode for the diagram, use the autoLayout statement inside the block defining the view. autoLayout [tb|bt|lr|rl] [rankSeparation] [nodeSeparation] The first property is the rank direction: tb : Top to bottom (default) bt : Bottom to top lr : Left to right rl : Right to left The second property is the separation of ranks in pixels (default: 300 ), while the third property is the separation of nodes in the same rank in pixels (default: 300 ). Please note that if your DSL workspace does not explicitly define any views, the DSL parser will automatically create a default set of views for you, with auto-layout enabled. To change this behaviour, you can either (1) explicitly define your views or (2) use a script to disable automatic layout ( example ). animation The animation keyword defines the animation for the specified view. Each animation step should be defined on a separate line, inside the block, specifying the elements that should be included in that step. animation { <identifier> [identifier...] <identifier> [identifier...] } title Overrides the title of the view. title <title> styles styles is the wrapper for one or more element/relationship styles, which are used when rendering diagrams. styles { ... } Permitted children: element relationship element style The element keyword is used to define an element style. All nested properties ( shape , icon , etc) are optional, see Structurizr - Notation for details about how tags and styles work. element <tag> { shape <Box|RoundedBox|Circle|Ellipse|Hexagon|Cylinder|Pipe|Person|Robot|Folder|WebBrowser|MobileDevicePortrait|MobileDeviceLandscape|Component> icon <file|url> width <integer> height <integer> background <#rrggbb> color <#rrggbb> colour <#rrggbb> stroke <#rrggbb> strokeWidth <integer: 1-10> fontSize <integer> border <solid|dashed|dotted> opacity <integer: 0-100> metadata <true|false> description <true|false> properties { name value } } Please note that element styles are designed to work with the Structurizr cloud service/on-premises installation/Lite, and may not be fully supported by the PlantUML, Mermaid, etc export formats. Important note: see Help - Icons if you are specifying an element style icon via a URL. relationship style The relationship keyword is used to define a relationship style. All nested properties ( thickness , color , etc) are optional, see Structurizr - Notation for details about how tags and styles work. relationship <tag> { thickness <integer> color #777777 colour #777777 style <solid|dashed|dotted> routing <Direct|Orthogonal|Curved> fontSize <integer> width <integer> position <integer: 0-100> opacity <integer: 0-100> properties { name value } } Please note that relationship styles are designed to work with the Structurizr cloud service/on-premises installation/Lite, and may not be fully supported by the PlantUML, Mermaid, etc export formats. theme The theme keyword can be used to specify a theme that should be used when rendering diagrams. See Structurizr - Themes for more details. theme <default|url> default can be used as a theme URL, to include the default Structurizr theme . themes The themes keyword can be used to specify one or more themes that should be used when rendering diagrams. See Structurizr - Themes for more details. themes <url> [url] ... [url] default can be used as a theme URL, to include the default Structurizr theme . branding The branding keyword allows you to define some custom branding that should be used when rendering diagrams and documentation. See Structurizr - Branding for more details. branding { logo <file|url> font <name> [url] } Important note: see Help - Icons if you are specifying a branding logo via a URL. terminology The terminology keyword allows you to override the terminology used when rendering diagrams (this may not be supported in all rendering tools). See Structurizr - Terminology for more details. terminology { enterprise <term> person <term> softwareSystem <term> container <term> component <term> deploymentNode <term> infrastructureNode <term> relationship <term> } configuration Finally, there are some configuration options that can be specified inside the configuration block. configuration { ... } Permitted children: users properties users The users block can be used to specify the users who should have read-only or read-write access to a workspace. Each username (e.g. e-mail address) and role pair should be specified on their own line. Valid roles are read (read-only) and write (read-write). users { <username> <read|write> } Documentation The !docs keyword can be used to attach Markdown/AsciiDoc documentation to the parent context (either the workspace, or a software system). !docs <path> <fully qualified class name> The path must be a relative path, located within the same directory as the parent file, or a subdirectory of it. For example: !docs subdirectory By default, the com.structurizr.documentation.importer.DefaultDocumentationImporter class will be used to import documentation as follows: All Markdown and AsciiDoc files in the given directory will be imported, alphabetically according to the filename. Each file must represent a separate documentation section, and the second level heading ( ## Section Title in Markdown and == Section Title in AsciiDoc) will be used as the section name. All images in the given directory (and sub-directories) are also imported into the workspace. The above behaviour can be customised by specifying the fully qualified class name of your own implementation of DocumentationImporter , which needs to be on the DSL classpath or installed as a JAR file in the plugins directory next to your DSL file. Architecture decision records (ADRs) The !adrs keyword can be used to attach Markdown/AsciiDoc ADRs to the parent context (either the workspace, or a software system). !adrs <path> <fully qualified class name> The path must be a relative path, located within the same directory as the parent file, or a subdirectory of it. For example: !adrs subdirectory By default, the com.structurizr.documentation.importer.AdrToolsDecisionImporter class will be used to import ADRs as follows: All Markdown files in this directory will be imported, alphabetically according to the filename. The files must have been created by adr-tools , or at least follow the same format. All images in the given directory (and sub-directories) are also imported into the workspace. The above behaviour can be customised by specifying the fully qualified class name of your own implementation of DocumentationImporter , which needs to be on the DSL classpath or installed as a JAR file in the plugins directory next to your DSL file.","title":"Grammar"},{"location":"language-reference/grammar/#grammar","text":"The following describes the language grammar, with angle brackets ( <...> ) used to show required properties, and square brackets ( [...] ) used to show optional properties. Most statements are of the form: keyword <required properties> [optional properties]","title":"Grammar"},{"location":"language-reference/grammar/#workspace","text":"workspace is the top level language construct, and the wrapper for the model and views . A workspace can optionally be given a name and description. workspace [name] [description] { ... } A workspace can also extend another workspace, to add more elements, relationships, views, etc to it. workspace extends <file|url> { ... } The base workspace can either be referenced using a local DSL/JSON file, or a remote (via a HTTPS URL) DSL/JSON file. When extending a DSL-based workspace, all of the identifiers defined in that workspace are available to use in the extended workspace. Permitted children: name description properties !docs !adrs !identifiers !impliedRelationships model views configuration","title":"workspace"},{"location":"language-reference/grammar/#model","text":"Each workspace must contain a model block, inside which elements and relationships are defined. model { ... } Permitted children: enterprise group person softwareSystem deploymentEnvironment element -> (relationship)","title":"model"},{"location":"language-reference/grammar/#enterprise","text":"The enterprise keyword provides a way to define a named \"enterprise\" (e.g. an organisation) within the top-level model. Any people or software systems defined inside this block will be deemed to be \"internal\", while all others will be deemed to be \"external\". On System Landscape and System Context diagrams, an enterprise is represented as a dashed box. Only a single enterprise can be defined within a model. enterprise [name] { ... } Permitted children: group person softwareSystem -> (relationship)","title":"enterprise"},{"location":"language-reference/grammar/#group","text":"The group keyword provides a way to define a named grouping of elements, which will be rendered as a boundary around those elements. See groups.dsl for an example. group <name> { ... } Groups can be defined as follows: Location Permitted elements Model People and software systems Software System Containers Container Components Groups cannot be nested.","title":"group"},{"location":"language-reference/grammar/#person","text":"The person keyword defines a person (e.g. a user, actor, role, or persona). person <name> [description] [tags] { ... } The following tags are added by default: Element Person Permitted children: description tags url properties perspectives -> (relationship)","title":"person"},{"location":"language-reference/grammar/#softwaresystem","text":"The softwareSystem keyword defines a software system. softwareSystem <name> [description] [tags] { ... } The following tags are added by default: Element Software System Permitted children: group container !docs !adrs description tags url properties perspectives -> (relationship)","title":"softwareSystem"},{"location":"language-reference/grammar/#container","text":"The container keyword defines a container, within a software system. container <name> [description] [technology] [tags] { ... } The following tags are added by default: Element Container Permitted children: group component description technology tags url properties perspectives -> (relationship)","title":"container"},{"location":"language-reference/grammar/#component","text":"The component keyword defines a component, within a container. component <name> [description] [technology] [tags] { ... } The following tags are added by default: Element Component Permitted children: description technology tags url properties perspectives -> (relationship)","title":"component"},{"location":"language-reference/grammar/#deploymentenvironment","text":"The deploymentEnvironment keyword provides a way to define a deployment environment (e.g. development, testing, staging, live, etc). deploymentEnvironment <name> { ... } Permitted children: deploymentGroup deploymentNode -> (relationship)","title":"deploymentEnvironment"},{"location":"language-reference/grammar/#deploymentgroup","text":"The deploymentGroup keyword provides a way to define a named deployment group. deploymentGroup <name> When software system/container instances are added to a deployment environment, all of the relationships between these elements are automatically replicated between all instances. Deployment groups provide a way to restrict the scope in which relationships are replicated. See deployment-groups.dsl for an example.","title":"deploymentGroup"},{"location":"language-reference/grammar/#deploymentnode","text":"The deploymentNode keyword is used to define a deployment node. deploymentNode <name> [description] [technology] [tags] [instances] { ... } The following tags are added by default: Element Deployment Node Permitted children: deploymentNode (deployment nodes can be nested) infrastructureNode softwareSystemInstance containerInstance -> (relationship) description technology instances tags url properties perspectives","title":"deploymentNode"},{"location":"language-reference/grammar/#infrastructurenode","text":"The infrastructureNode keyword defines an infrastructure node, which is typically something like a load balancer, firewall, DNS service, etc. infrastructureNode <name> [description] [technology] [tags] { ... } The following tags are added by default: Element Infrastructure Node Permitted children: -> (relationship) description technology tags url properties perspectives","title":"infrastructureNode"},{"location":"language-reference/grammar/#softwaresysteminstance","text":"The softwareSystemInstance keyword defines an instance of the specified software system that is deployed on the parent deployment node. softwareSystemInstance <identifier> [deploymentGroups] [tags] { ... } The identifier must represent a software system. deploymentGroups is a comma seperated list of identifiers representing deployment groups. In addition to the software system's tags, the following tags are added by default: Software System Instance Permitted children: -> (relationship) description tags url properties perspectives healthCheck","title":"softwareSystemInstance"},{"location":"language-reference/grammar/#containerinstance","text":"The containerInstance keyword defines an instance of the specified container that is deployed on the parent deployment node. containerInstance <identifier> [deploymentGroups] [tags] { ... } The identifier must represent a container. deploymentGroups is a comma seperated list of identifiers representing deployment groups. In addition to the container's tags, the following tags are added by default: Container Instance Permitted children: -> (relationship) description tags url properties perspectives healthCheck","title":"containerInstance"},{"location":"language-reference/grammar/#healthcheck","text":"The healthCheck keyword defines a HTTP health check for the parent software system/container instance. healthCheck <name> <url> [interval] [timeout] The interval is a number of seconds (default 60s), and the timeout is a number of milliseconds (default 0ms).","title":"healthCheck"},{"location":"language-reference/grammar/#element","text":"The element keyword defines a custom element (this is only available on the Structurizr cloud service/on-premises installation/Lite). element <name> [metadata] [description] [tags] { ... } The following tags are added by default: Element Permitted children: description tags url properties perspectives -> (relationship)","title":"element"},{"location":"language-reference/grammar/#relationship","text":"-> is used to define a uni-directional relationship between two elements. There are two ways to define relationships. The first is explicitly, where you explicitly use a source identifier: <identifier> -> <identifier> [description] [technology] [tags] { ... } For example: user -> softwareSystem \"Uses\" And the second is implicitly, where the relationship source is the element in scope: -> <identifier> [description] [technology] [tags] For example: person user { -> softwareSystem \"Uses\" } This is equivalent to the following, where the special this identifier is used to refer to the element in scope: person user { this -> softwareSystem \"Uses\" } The following tags are added to relationships by default: Relationship The following types of relationships can be created using the DSL: Source Destination Person Person, Software System, Container, Component Software System Person, Software System, Container, Component Container Person, Software System, Container, Component Component Person, Software System, Container, Component Deployment Node Deployment Node Infrastructure Node Deployment Node, Infrastructure Node, Software System Instance, Container Instance Software System Instance Infrastructure Node Container Instance Infrastructure Node Permitted children: tags url properties perspectives","title":"relationship"},{"location":"language-reference/grammar/#tags","text":"tags is used to add tags to an element or relationship. Tags can be specified comma separated, or individually. tags \"Tag 1\" tags \"Tag 1,Tag 2\" tags \"Tag 1\" \"Tag 2\"","title":"tags"},{"location":"language-reference/grammar/#description","text":"description is used to set the description on an element or view. description \"Description\"","title":"description"},{"location":"language-reference/grammar/#technology","text":"technology is used to set the technology on a container, component, deployment node, infrastructure node. technology \"Technology\"","title":"technology"},{"location":"language-reference/grammar/#instances","text":"instances is used to set the number of instances of a deployment node. instances \"4\"","title":"instances"},{"location":"language-reference/grammar/#url","text":"url is used to set a URL on an element or relationship. url https://example.com","title":"url"},{"location":"language-reference/grammar/#properties","text":"The properties block is used to define one or more name/value properties. properties { <name> <value> ... }","title":"properties"},{"location":"language-reference/grammar/#perspectives","text":"The perspectives block is used to define one or more name/description perspectives for an element or relationship. See Help - Perspectives for how these are used. perspectives { <name> <description> ... }","title":"perspectives"},{"location":"language-reference/grammar/#ref","text":"The !ref keyword provides a way to reference a previously defined element/relationship, and is designed to be used with the workspace extends or !include features. It can be used in a couple of ways. The first usage scenario is to reference an existing element/relationship that has been defined via the DSL. This allows you to extend the element referenced by the given identifier. !ref <identifier> { ... } Or, if you're extending a JSON-based workspace, you can reference an element by its \"canonical name\", and assign that to an identifier. <identifier> = !ref <canonical name> { ... } See ref.dsl for some usage examples. Please note that !ref is currently an experimental feature.","title":"!ref"},{"location":"language-reference/grammar/#views","text":"Each workspace can also contain one or more views, defined with the views block. views { ... } The views block can contain the following: systemLandscape systemContext container component filtered dynamic deployment custom styles theme themes branding terminology properties","title":"views"},{"location":"language-reference/grammar/#systemlandscape-view","text":"The systemLandscape keyword is used to define a System Landscape view . systemLandscape [key] [description] { ... } Permitted children: include exclude autoLayout animation title description properties","title":"systemLandscape view"},{"location":"language-reference/grammar/#systemcontext-view","text":"The systemContext keyword is used to define a System Context view for the specified software system. systemContext <software system identifier> [key] [description] { ... } Permitted children: include exclude autoLayout animation title description properties","title":"systemContext view"},{"location":"language-reference/grammar/#container-view","text":"The container keyword is used to define a Container view for the specified software system. container <software system identifier> [key] [description] { ... } Permitted children: include exclude autoLayout animation title description properties","title":"container view"},{"location":"language-reference/grammar/#component-view","text":"The component keyword is used to define a Component view for the specified container. component <container identifier> [key] [description] { ... } Permitted children: include exclude autoLayout animation title description properties","title":"component view"},{"location":"language-reference/grammar/#filtered-view","text":"The filtered keyword is used to define a Filtered view on top of the specified view. filtered <baseKey> <include|exclude> <tags> [key] [description] The baseKey specifies the key of the System Landscape, System Context, Container, or Component view on which this filtered view should be based. The mode ( include or exclude ) defines whether the view should include or exclude elements/relationships based upon the tags provided. Please note that once a filtered view is defined for a given \"base view\", that base view will no longer show up in your diagram list when using the Structurizr renderer. This is by design. If you'd like to see the base view too, just create another filtered view for the same base view, which includes the Element and Relationship tags. filtered <baseKey> include \"Element,Relationship\" [key] [description]","title":"filtered view"},{"location":"language-reference/grammar/#dynamic-view","text":"The dynamic keyword defines a Dynamic view for the specified scope. dynamic <*|software system identifier|container identifier> [key] [description] { ... } The first property defines the scope of the view, and therefore what can be added to the view, as follows: * scope: People and software systems. Software system scope: People, other software systems, and containers. Container scope: People, other software systems, other containers, and components. Unlike the other diagram types, Dynamic views are created by specifying the relationships that should be added to the view, within the dynamic block, as follows: <element identifier> -> <element identifier> [description] [technology] <relationship identifier> [description] With a dynamic view, you're showing instances of relationships that are defined in the static model. For example, imagine that you have two software systems defined in the static model, with a single relationship between them described as \"Sends data to\". A dynamic view allows you to override the relationship description, to better describe the interaction in the context of the behaviour you're diagramming. See dynamic.dsl for an example of this, and Modelling multiple relationships for some tips on how to best model multiple relationships between two elements in order to avoid cluttering your static model. For convenience, if a relationship between the two elements does not exist in the static model, the DSL parser will automatically create it for you. See parallel.dsl for an example of how to create dynamic diagrams with parallel sequences. Permitted children: autoLayout title description properties","title":"dynamic view"},{"location":"language-reference/grammar/#deployment-view","text":"The deployment keyword defines a Deployment view for the specified scope and deployment environment. deployment <*|software system identifier> <environment> [key] [description] { ... } The first property defines the scope of the view, and the second property defines the deployment environment (which can be an identifier, or a name). The combination of these two properties determines what can be added to the view, as follows: * scope: All deployment nodes, infrastructure nodes, and container instances within the deployment environment. Software system scope: All deployment nodes and infrastructure nodes within the deployment environment. Container instances within the deployment environment that belong to the software system. Permitted children: include exclude autoLayout animation title description properties","title":"deployment view"},{"location":"language-reference/grammar/#custom-view","text":"The custom keyword is used to define a custom view (this is only available on the Structurizr cloud service/on-premises installation). custom [key] [title] [description] { ... } Permitted children: include exclude autoLayout animation title description properties","title":"custom view"},{"location":"language-reference/grammar/#include","text":"The include keyword can be used to include elements or relationships.","title":"include"},{"location":"language-reference/grammar/#including-elements","text":"To include elements in a view, use one or more include statements inside the block defining the view. include <*|identifier|expression> [*|identifier|expression...] Elements can either be specified using individual identifiers, the wildcard identifier ( * ), or a property expression. Please note that including elements will also include the relationships between those elements. The wildcard identifier ( * ) operates differently depending upon the type of diagram, as follows: System Landscape view: Include all people and software systems. System Context view: Include the software system in scope; plus all people and software systems that are directly connected to the software system in scope. Container view: Include all containers within the software system in scope; plus all people and software systems that are directly connected to those containers. Component view: Include all components within the container in scope; plus all people, software systems and containers (belonging to the software system in scope) directly connected to them. Filtered view: (not applicable) Dynamic view: (not applicable) Deployment view: Include all deployment nodes, infrastructure nodes, and container instances defined within the deployment environment and (optional) software system in scope. They provide a way to include elements based upon some basic conditional logic, as follows: element.tag==<tag>,[tag] : include elements that have all of the specified tags element.tag!=<tag>,[tag] : include elements that do not have all of the specified tags","title":"Including elements"},{"location":"language-reference/grammar/#including-relationships","text":"To include a relationship in a view, you can specify an individual relationship identifier, or an expression: include <identifier|expression> [identifier|expression...] Relationship expressions only operate on elements that exist in the view.","title":"Including relationships"},{"location":"language-reference/grammar/#exclude","text":"The exclude keyword can be used to exclude elements or relationships.","title":"exclude"},{"location":"language-reference/grammar/#excluding-elements","text":"To exclude specific elements, use one or more exclude statements inside the block defining the view. exclude <identifier|expression> [identifier|expression...]","title":"Excluding elements"},{"location":"language-reference/grammar/#excluding-relationships","text":"To exclude a relationship in a view, you can specify an individual relationship identifier, or use a property expression: exclude <identifier|expression> [identifier|expression...] They provide a way to exclude relationships based upon some basic conditional logic, as follows: relationship.tag==<tag>,[tag] : exclude relationships that have all of the specified tags relationship.tag!=<tag>,[tag] : exclude relationships that do not have all of the specified tags Alternatively, you can use the relationship expression syntax as follows (please note the double quotes surrounding the entire expression): exclude \"<*|identifier> -> <*|identifier>\" The combinations of parameters are: * -> * : all relationships between all elements source -> * : all relationships from source to any element * -> destination : all relationships from any element to destination source -> destination : all relationships from source to destination The relationship expression syntax only operates on elements that exist in the view.","title":"Excluding relationships"},{"location":"language-reference/grammar/#autolayout","text":"To enable automatic layout mode for the diagram, use the autoLayout statement inside the block defining the view. autoLayout [tb|bt|lr|rl] [rankSeparation] [nodeSeparation] The first property is the rank direction: tb : Top to bottom (default) bt : Bottom to top lr : Left to right rl : Right to left The second property is the separation of ranks in pixels (default: 300 ), while the third property is the separation of nodes in the same rank in pixels (default: 300 ). Please note that if your DSL workspace does not explicitly define any views, the DSL parser will automatically create a default set of views for you, with auto-layout enabled. To change this behaviour, you can either (1) explicitly define your views or (2) use a script to disable automatic layout ( example ).","title":"autoLayout"},{"location":"language-reference/grammar/#animation","text":"The animation keyword defines the animation for the specified view. Each animation step should be defined on a separate line, inside the block, specifying the elements that should be included in that step. animation { <identifier> [identifier...] <identifier> [identifier...] }","title":"animation"},{"location":"language-reference/grammar/#title","text":"Overrides the title of the view. title <title>","title":"title"},{"location":"language-reference/grammar/#styles","text":"styles is the wrapper for one or more element/relationship styles, which are used when rendering diagrams. styles { ... } Permitted children: element relationship","title":"styles"},{"location":"language-reference/grammar/#element-style","text":"The element keyword is used to define an element style. All nested properties ( shape , icon , etc) are optional, see Structurizr - Notation for details about how tags and styles work. element <tag> { shape <Box|RoundedBox|Circle|Ellipse|Hexagon|Cylinder|Pipe|Person|Robot|Folder|WebBrowser|MobileDevicePortrait|MobileDeviceLandscape|Component> icon <file|url> width <integer> height <integer> background <#rrggbb> color <#rrggbb> colour <#rrggbb> stroke <#rrggbb> strokeWidth <integer: 1-10> fontSize <integer> border <solid|dashed|dotted> opacity <integer: 0-100> metadata <true|false> description <true|false> properties { name value } } Please note that element styles are designed to work with the Structurizr cloud service/on-premises installation/Lite, and may not be fully supported by the PlantUML, Mermaid, etc export formats. Important note: see Help - Icons if you are specifying an element style icon via a URL.","title":"element style"},{"location":"language-reference/grammar/#relationship-style","text":"The relationship keyword is used to define a relationship style. All nested properties ( thickness , color , etc) are optional, see Structurizr - Notation for details about how tags and styles work. relationship <tag> { thickness <integer> color #777777 colour #777777 style <solid|dashed|dotted> routing <Direct|Orthogonal|Curved> fontSize <integer> width <integer> position <integer: 0-100> opacity <integer: 0-100> properties { name value } } Please note that relationship styles are designed to work with the Structurizr cloud service/on-premises installation/Lite, and may not be fully supported by the PlantUML, Mermaid, etc export formats.","title":"relationship style"},{"location":"language-reference/grammar/#theme","text":"The theme keyword can be used to specify a theme that should be used when rendering diagrams. See Structurizr - Themes for more details. theme <default|url> default can be used as a theme URL, to include the default Structurizr theme .","title":"theme"},{"location":"language-reference/grammar/#themes","text":"The themes keyword can be used to specify one or more themes that should be used when rendering diagrams. See Structurizr - Themes for more details. themes <url> [url] ... [url] default can be used as a theme URL, to include the default Structurizr theme .","title":"themes"},{"location":"language-reference/grammar/#branding","text":"The branding keyword allows you to define some custom branding that should be used when rendering diagrams and documentation. See Structurizr - Branding for more details. branding { logo <file|url> font <name> [url] } Important note: see Help - Icons if you are specifying a branding logo via a URL.","title":"branding"},{"location":"language-reference/grammar/#terminology","text":"The terminology keyword allows you to override the terminology used when rendering diagrams (this may not be supported in all rendering tools). See Structurizr - Terminology for more details. terminology { enterprise <term> person <term> softwareSystem <term> container <term> component <term> deploymentNode <term> infrastructureNode <term> relationship <term> }","title":"terminology"},{"location":"language-reference/grammar/#configuration","text":"Finally, there are some configuration options that can be specified inside the configuration block. configuration { ... } Permitted children: users properties","title":"configuration"},{"location":"language-reference/grammar/#users","text":"The users block can be used to specify the users who should have read-only or read-write access to a workspace. Each username (e.g. e-mail address) and role pair should be specified on their own line. Valid roles are read (read-only) and write (read-write). users { <username> <read|write> }","title":"users"},{"location":"language-reference/grammar/#documentation","text":"The !docs keyword can be used to attach Markdown/AsciiDoc documentation to the parent context (either the workspace, or a software system). !docs <path> <fully qualified class name> The path must be a relative path, located within the same directory as the parent file, or a subdirectory of it. For example: !docs subdirectory By default, the com.structurizr.documentation.importer.DefaultDocumentationImporter class will be used to import documentation as follows: All Markdown and AsciiDoc files in the given directory will be imported, alphabetically according to the filename. Each file must represent a separate documentation section, and the second level heading ( ## Section Title in Markdown and == Section Title in AsciiDoc) will be used as the section name. All images in the given directory (and sub-directories) are also imported into the workspace. The above behaviour can be customised by specifying the fully qualified class name of your own implementation of DocumentationImporter , which needs to be on the DSL classpath or installed as a JAR file in the plugins directory next to your DSL file.","title":"Documentation"},{"location":"language-reference/grammar/#architecture-decision-records-adrs","text":"The !adrs keyword can be used to attach Markdown/AsciiDoc ADRs to the parent context (either the workspace, or a software system). !adrs <path> <fully qualified class name> The path must be a relative path, located within the same directory as the parent file, or a subdirectory of it. For example: !adrs subdirectory By default, the com.structurizr.documentation.importer.AdrToolsDecisionImporter class will be used to import ADRs as follows: All Markdown files in this directory will be imported, alphabetically according to the filename. The files must have been created by adr-tools , or at least follow the same format. All images in the given directory (and sub-directories) are also imported into the workspace. The above behaviour can be customised by specifying the fully qualified class name of your own implementation of DocumentationImporter , which needs to be on the DSL classpath or installed as a JAR file in the plugins directory next to your DSL file.","title":"Architecture decision records (ADRs)"},{"location":"language-reference/identifiers/","text":"Identifiers By default, all elements and relationships are anonymous, in that they can't be referenced from within the DSL. For example, the following statements will create a person and a software system, but neither can be referenced within the DSL. person \"User\" softwareSystem \"Software System\" To create a relationship between the two elements, we need to be able to reference them. We can do this by defining an identifier, in the same way that you'd define a variable in many programming languages. p = person \"User\" ss = softwareSystem \"Software System\" Now we can use these identifiers when creating relationships, specifying which elements should be included/excluded from views, etc. p -> ss \"Uses\" Identifiers are only needed where you plan to reference the element/relationship. Identifier scope By default, all identifiers are treated as being globally scoped and flat , so the following will fail with an error message saying that the api identifier is already in use. workspace { model { softwareSystem1 = softwareSystem \"Software System 1\" { api = container \"API\" } softwareSystem2 = softwareSystem \"Software System 2\" { api = container \"API\" } } } The !identifiers keyword allows you to specify that element identifiers should be treated as hierarchical (relationship identifiers are unaffected by this setting). For example: workspace { !identifiers hierarchical model { softwareSystem1 = softwareSystem \"Software System 1\" { api = container \"API\" } softwareSystem2 = softwareSystem \"Software System 2\" { api = container \"API\" } } } Now the two API containers are referenceable via softwareSystem1.api and softwareSystem2.api respectively. !impliedRelationships !impliedRelationships <true|false> The !impliedRelationships keyword provides a way to enable or disable whether implied relationships are created. A value of false disables implied relationship creation, while true creates implied relationships between all valid combinations of the parent elements, unless any relationship already exists between them (see Structurizr for Java - Implied relationships - CreateImpliedRelationshipsUnlessAnyRelationshipExistsStrategy for more details).","title":"Identifiers"},{"location":"language-reference/identifiers/#identifiers","text":"By default, all elements and relationships are anonymous, in that they can't be referenced from within the DSL. For example, the following statements will create a person and a software system, but neither can be referenced within the DSL. person \"User\" softwareSystem \"Software System\" To create a relationship between the two elements, we need to be able to reference them. We can do this by defining an identifier, in the same way that you'd define a variable in many programming languages. p = person \"User\" ss = softwareSystem \"Software System\" Now we can use these identifiers when creating relationships, specifying which elements should be included/excluded from views, etc. p -> ss \"Uses\" Identifiers are only needed where you plan to reference the element/relationship.","title":"Identifiers"},{"location":"language-reference/identifiers/#identifier-scope","text":"By default, all identifiers are treated as being globally scoped and flat , so the following will fail with an error message saying that the api identifier is already in use. workspace { model { softwareSystem1 = softwareSystem \"Software System 1\" { api = container \"API\" } softwareSystem2 = softwareSystem \"Software System 2\" { api = container \"API\" } } } The !identifiers keyword allows you to specify that element identifiers should be treated as hierarchical (relationship identifiers are unaffected by this setting). For example: workspace { !identifiers hierarchical model { softwareSystem1 = softwareSystem \"Software System 1\" { api = container \"API\" } softwareSystem2 = softwareSystem \"Software System 2\" { api = container \"API\" } } } Now the two API containers are referenceable via softwareSystem1.api and softwareSystem2.api respectively.","title":"Identifier scope"},{"location":"language-reference/identifiers/#impliedrelationships","text":"!impliedRelationships <true|false> The !impliedRelationships keyword provides a way to enable or disable whether implied relationships are created. A value of false disables implied relationship creation, while true creates implied relationships between all valid combinations of the parent elements, unless any relationship already exists between them (see Structurizr for Java - Implied relationships - CreateImpliedRelationshipsUnlessAnyRelationshipExistsStrategy for more details).","title":"!impliedRelationships"},{"location":"language-reference/include/","text":"Includes The !include keyword can be used to include one or more files, to provide some degree of modularity, and to reuse definition fragments between workspaces. The content of any included files is simply inlined into the parent document, in the order the files are discovered. !include <file|directory|url> file: a single local file, specified by a relative path, located within the same directory as the parent file or a subdirectory of it file: a local directory containing one or more DSL files, specified by a relative path, located within the same directory as the parent file or a subdirectory of it url: a HTTPS URL pointing to a single DSL file Some examples are: !include people.dsl !include model/people.dsl !include model !include https://example.com/model/people.dsl","title":"Includes"},{"location":"language-reference/include/#includes","text":"The !include keyword can be used to include one or more files, to provide some degree of modularity, and to reuse definition fragments between workspaces. The content of any included files is simply inlined into the parent document, in the order the files are discovered. !include <file|directory|url> file: a single local file, specified by a relative path, located within the same directory as the parent file or a subdirectory of it file: a local directory containing one or more DSL files, specified by a relative path, located within the same directory as the parent file or a subdirectory of it url: a HTTPS URL pointing to a single DSL file Some examples are: !include people.dsl !include model/people.dsl !include model !include https://example.com/model/people.dsl","title":"Includes"},{"location":"language-reference/plugins/","text":"Plugins Plugins can be used where more control or customisation is required, and provide access to the workspace via the Structurizr for Java library . For example, you could use a plugin to create model elements based upon an external data source, or perhaps define views programmatically. Plugins can be used at any point in the DSL. To write a plugin, create a Java class that implements the com.structurizr.dsl.StructurizrDslPlugin interface (you will need to add a dependency on the DSL library, which can be found on Maven Central via com.structurizr:structurizr-dsl ). package com.example; import com.structurizr.Workspace; public class TestPlugin implements StructurizrDslPlugin { @Override public void run(StructurizrDslPluginContext context) { Workspace workspace = context.getWorkspace(); workspace.setName(\"Name set by plugin\"); } } The compiled plugin packaged as a JAR file (plus any other JAR dependencies) should be placed in a directory named plugins next to your DSL file. You can then use your plugin from the DSL using the !plugin keyword. ``` workspace { !plugin com.example.TestPlugin } Parameters can be specified in the plugin body, for example. ``` workspace { !plugin com.example.TestPlugin { name value } } The named parameters are then available via the getParameter(name) method of the StructurizrDslPluginContext object. Please note that !plugin is currently an experimental feature.","title":"Plugins"},{"location":"language-reference/plugins/#plugins","text":"Plugins can be used where more control or customisation is required, and provide access to the workspace via the Structurizr for Java library . For example, you could use a plugin to create model elements based upon an external data source, or perhaps define views programmatically. Plugins can be used at any point in the DSL. To write a plugin, create a Java class that implements the com.structurizr.dsl.StructurizrDslPlugin interface (you will need to add a dependency on the DSL library, which can be found on Maven Central via com.structurizr:structurizr-dsl ). package com.example; import com.structurizr.Workspace; public class TestPlugin implements StructurizrDslPlugin { @Override public void run(StructurizrDslPluginContext context) { Workspace workspace = context.getWorkspace(); workspace.setName(\"Name set by plugin\"); } } The compiled plugin packaged as a JAR file (plus any other JAR dependencies) should be placed in a directory named plugins next to your DSL file. You can then use your plugin from the DSL using the !plugin keyword. ``` workspace { !plugin com.example.TestPlugin } Parameters can be specified in the plugin body, for example. ``` workspace { !plugin com.example.TestPlugin { name value } } The named parameters are then available via the getParameter(name) method of the StructurizrDslPluginContext object. Please note that !plugin is currently an experimental feature.","title":"Plugins"},{"location":"language-reference/scripts/","text":"Scripts Scripts are like plugins, except they don't need to be compiled before use. JavaScript(*), Kotlin, Groovy, and Ruby are supported out of the box, and you can add more languages via the Java Scripting API. The workspace (again from the Structurizr for Java library ) is bound to a variable named workspace . Scripts can be used at any point in the DSL. Please note that !script is currently an experimental feature. (*) Nashorn (the JVM JavaScript engine) is deprecated, see https://openjdk.java.net/jeps/372 for details. Inline scripts To use an inline script, use the !script keyword followed by the language you'd like to use ( groovy , kotlin , or javascript ). For example, the following Kotlin script will create the default set of views, without automatic layout enabled. !script kotlin { workspace.views.createDefaultViews() workspace.views.views.forEach { it.disableAutomaticLayout() } } Please note that inline scripts cannot have a line that only contains a closing } character. External scripts To use an external script, create a script file next to your DSL file (e.g. script.kts ). workspace.views.createDefaultViews() workspace.views.views.forEach { it.disableAutomaticLayout() } You can then use your script from the DSL using the !script keyword. !script script.kts The following file extensions are recognised: .groovy (Groovy) .kts (Kotlin) .rb (Ruby) .js (JavaScript)","title":"Scripts"},{"location":"language-reference/scripts/#scripts","text":"Scripts are like plugins, except they don't need to be compiled before use. JavaScript(*), Kotlin, Groovy, and Ruby are supported out of the box, and you can add more languages via the Java Scripting API. The workspace (again from the Structurizr for Java library ) is bound to a variable named workspace . Scripts can be used at any point in the DSL. Please note that !script is currently an experimental feature. (*) Nashorn (the JVM JavaScript engine) is deprecated, see https://openjdk.java.net/jeps/372 for details.","title":"Scripts"},{"location":"language-reference/scripts/#inline-scripts","text":"To use an inline script, use the !script keyword followed by the language you'd like to use ( groovy , kotlin , or javascript ). For example, the following Kotlin script will create the default set of views, without automatic layout enabled. !script kotlin { workspace.views.createDefaultViews() workspace.views.views.forEach { it.disableAutomaticLayout() } } Please note that inline scripts cannot have a line that only contains a closing } character.","title":"Inline scripts"},{"location":"language-reference/scripts/#external-scripts","text":"To use an external script, create a script file next to your DSL file (e.g. script.kts ). workspace.views.createDefaultViews() workspace.views.views.forEach { it.disableAutomaticLayout() } You can then use your script from the DSL using the !script keyword. !script script.kts The following file extensions are recognised: .groovy (Groovy) .kts (Kotlin) .rb (Ruby) .js (JavaScript)","title":"External scripts"},{"location":"language-reference/string-substitution/","text":"String Substitution String substitution will take place on any text specified using the ${NAME} syntax, where NAME corresponds to a constant or an environment variable. For example: !constant ORGANISATION_NAME \"Organisation\" !constant GROUP_NAME \"Group\" workspace { model { enterprise \"${ORGANISATION_NAME} - ${GROUP_NAME}\" { user = person \"User\" } } } If a named constant or environment variable cannot be found, the string will not be substituted. Names may only contain the following characters: a-zA-Z0-9-_.","title":"String Substitution"},{"location":"language-reference/string-substitution/#string-substitution","text":"String substitution will take place on any text specified using the ${NAME} syntax, where NAME corresponds to a constant or an environment variable. For example: !constant ORGANISATION_NAME \"Organisation\" !constant GROUP_NAME \"Group\" workspace { model { enterprise \"${ORGANISATION_NAME} - ${GROUP_NAME}\" { user = person \"User\" } } } If a named constant or environment variable cannot be found, the string will not be substituted. Names may only contain the following characters: a-zA-Z0-9-_.","title":"String Substitution"}]}